small: type.
big: type.
s: small.
b: small -> big.

%{ == Syntax == }%

i: type. %name i T t.

eatom: type.
ψ: type.
≈ : i -> i -> ψ.  %infix none 20 ≈.
⊧: ψ -> type. %name ⊧ E e.

any : i.
lax : i.
any-lax : ⊧ (any ≈ lax).

refl : {X} ⊧ (X ≈ X).
trans : ⊧ (X ≈ Y) -> ⊧ (Y ≈ Z) -> ⊧ (X ≈ Z).

args: type.
● : args.
⋆ : i -> args -> args. %infix right 3 ⋆.
≋ : args -> args -> type.  %infix none 20 ≋.
≋-● : ● ≋ ●.
≋-⋆ : ⊧ (X ≈ Y) -> Xs ≋ Ys -> (X ⋆ Xs) ≋ (Y ⋆ Ys).
prim: eatom -> args -> ψ.

pol: type. %name pol P.
⁺: pol.
⁻: pol.

%{ We define propositions in an environment with free atoms. }%
atom: pol -> type. %name atom Q q.
%block atom⁺: block {Q⁺: atom ⁺}.
%block atom⁻: block {Q⁻: atom ⁻}.


typ: pol -> type. %name typ A.
c: atom P -> args -> typ P.

e: eatom -> args -> typ ⁺.
↓: typ ⁻ -> typ ⁺.
⊥: typ ⁺.
∨: typ ⁺ -> typ ⁺ -> typ ⁺. %infix none 5 ∨.
⊤⁺: typ ⁺.
∧⁺: typ ⁺ -> typ ⁺ -> typ ⁺. %infix none 5 ∧⁺.
∃: (i -> typ ⁺) -> typ ⁺.

↑: typ ⁺ -> typ ⁻.
⊤⁻: typ ⁻.
∧⁻: typ ⁻ -> typ ⁻ -> typ ⁻. %infix none 5 ∧⁻.
⊃: typ ⁺ -> typ ⁻ -> typ ⁻. %infix right 5 ⊃.
∀: (i -> typ ⁻) -> typ ⁻.

%{ Judgments (only one unless we're in the middle of an identity expansion) }%
suc: type. %name suc Suc γ.
true: typ ⁻ -> suc. %postfix 3 true.

%{ Hypothetical judgments (two, one for atoms and another for propositions) }%
hjmt: type. %name hjmt A.
h⁺: atom ⁺ -> args -> hjmt.
h⁻: typ ⁻ -> hjmt.

%{ Right-stable judgments are ones that are either atomic or shifted. }%
stable: suc -> type. %name stable St.
sa: stable (c Q Xs true).
s↑: stable (↑ A⁺ true).

%{ An inversion or focus context Ω is a list of positive propositions. }%
pos: type. %name pos _Ω.
·: pos.
,: typ ⁺ -> pos -> pos. %infix right 3 ,.

%{ == Sequent calculus == }%

%{ The judgments of the focused language (or, alternatively, syntax of
intrinsically typed spine form judgments) }%
hyp: hjmt -> type. %name hyp X x.
%abbrev hyp⁺ = [Q⁺][Xs] hyp (h⁺ Q⁺ Xs).
%abbrev hyp⁻ = [A⁻] hyp (h⁻ A⁻).
%block x : some {A: hjmt} block {x: hyp A}.
%block univ : block {t:i}.
%block casm: some {E:ψ} block {b: ⊧ E}.
%block gamma = (atom⁺ | atom⁻ | x | univ | casm). %% World for derivations, cut

rfoc: typ ⁺ -> type. %name rfoc V.
conc: pos -> suc -> type. %name conc N.
lfoc: typ ⁻ -> suc -> type. %name lfoc Sp.
%block v : some {A⁺: typ ⁺} block {v: rfoc A⁺}.
%block sp : some {A⁻: typ ⁻} block {γ}{st: stable γ}{sp: lfoc A⁻ γ}.
%block aleph = (gamma | v | sp). %% Extended world for identity expansion

%{ ``V ::= z ∣ {N}⁻ ∣ inl V ∣ inr V ∣ <> ∣ <V₁,V₂>'' }%

eR: ⊧ (prim E Xs) -> rfoc (e E Xs).
cR: Xs ≋ Ys -> hyp⁺ Q⁺ Xs -> rfoc (c Q⁺ Ys).
↓R: conc · (A⁻ true) -> rfoc (↓ A⁻).
∨R₁: rfoc A⁺ -> rfoc (A⁺ ∨ B⁺).
∨R₂: rfoc B⁺ -> rfoc (A⁺ ∨ B⁺).
∃R: {T} rfoc (A⁺ T) -> rfoc (∃ A⁺).
⊤⁺R: rfoc ⊤⁺.
∧⁺R: rfoc A⁺ -> rfoc B⁺ -> rfoc (A⁺ ∧⁺ B⁺).

%{ ``N ::= x • Sp ∣ z.p ∣ x.N ∣ abort ∣ [N₁,N₂] ∣ <>.N ∣ ∧⁺N ∣ {V}⁺ ∣ λN ∣ <> ∣ <N₁,N₂>'' }%
foc: hyp⁻ A⁻ -> stable Suc -> lfoc A⁻ Suc -> conc · Suc.
eL: (⊧ (prim E Xs) -> conc _Ω Suc) -> conc (e E Xs , _Ω) Suc.
cL: (hyp⁺ Q⁺ Xs -> conc _Ω Suc) -> conc (c Q⁺ Xs , _Ω) Suc.
↓L: (hyp⁻ A⁻ -> conc _Ω Suc) -> conc (↓ A⁻ , _Ω) Suc.
⊥L: conc (⊥ , _Ω) Suc.
∨L: conc (A⁺ , _Ω) Suc -> conc (B⁺ , _Ω) Suc -> conc (A⁺ ∨ B⁺ , _Ω) Suc.
∃L: ({T:i} conc (A⁺ T , _Ω) Suc) -> conc ((∃ A⁺) , _Ω) Suc.

⊤⁺L: conc _Ω Suc -> conc (⊤⁺ , _Ω) Suc.
∧⁺L: conc (A⁺ , B⁺ , _Ω) Suc -> conc (A⁺ ∧⁺ B⁺ , _Ω) Suc.
↑R: rfoc A⁺ -> conc · (↑ A⁺ true).
⊤⁻R: conc · (⊤⁻ true).
∧⁻R: conc · (A⁻ true) -> conc · (B⁻ true) -> conc · (A⁻ ∧⁻ B⁻ true).
⊃R: conc (A⁺ , ·) (B⁻ true) -> conc · (A⁺ ⊃ B⁻ true).
∀R: ({t:i} conc · ((A⁻ t) true)) -> conc · (∀ A⁻ true).

%{ ``Sp ::= nil ∣ {N} ∣ π₁;Sp ∣ π₂;Sp ∣ V;Sp'' }%
p⁻: Xs ≋ Ys -> lfoc (c Q⁻ Xs) (c Q⁻ Ys true).
↑L: conc (A⁺ , ·) Suc -> lfoc (↑ A⁺) Suc.
∧⁻L₁: lfoc A⁻ Suc -> lfoc (A⁻ ∧⁻ B⁻) Suc.
∧⁻L₂: lfoc B⁻ Suc -> lfoc (A⁻ ∧⁻ B⁻) Suc.
⊃L: rfoc A⁺ -> lfoc B⁻ Suc -> lfoc (A⁺ ⊃ B⁻) Suc.
∀L: {T:i} lfoc (A⁻ T) Suc -> lfoc (∀ A⁻) Suc.

%{ === equivalence === }%

≋-refl: {Xs} Xs ≋ Xs -> type.
%mode ≋-refl +Xs -D.
-: ≋-refl ● ≋-●.
-: ≋-refl (X ⋆ Xs) (≋-⋆ (refl X) D) <- ≋-refl Xs D.
%worlds (gamma) (≋-refl Xs D).
%total (Xs) (≋-refl Xs D).

≋-trans: Xs ≋ Ys -> Ys ≋ Zs -> Xs ≋ Zs -> type.
%mode ≋-trans +D1 +D2 -D3.
-: ≋-trans ≋-● ≋-● ≋-●.
-: ≋-trans (≋-⋆ DXY DXYS) (≋-⋆ DYZ DYZS) (≋-⋆ (trans DXY DYZ) DXZS)
    <- ≋-trans DXYS DYZS DXZS.
%worlds (gamma) (≋-trans D1 D2 D3).
%total (D1) (≋-trans D1 D2 D3).

swap : Xs ≋ Ys -> conc _Ω (c Q⁻ Xs true) -> conc _Ω (c Q⁻ Ys true) -> type.
swap-rfoc : Xs ≋ Ys -> rfoc (↓ (c Q⁻ Xs)) -> rfoc (↓ (c Q⁻ Ys)) -> type.
swap-lfoc : Xs ≋ Ys -> lfoc A⁻ (c Q⁻ Xs true) -> lfoc A⁻ (c Q⁻ Ys true) -> type.
%mode swap +D +E -F.
%mode swap-rfoc +D +E -F.
%mode swap-lfoc +D +E -F.

-: swap-rfoc E (↓R D) (↓R D')
    <- swap E D D'.

-: swap-lfoc (D: Xs ≋ Ys) (p⁻ (D₁: Zs ≋ Xs)) (p⁻ (D₁': Zs ≋ Ys))
    <- ≋-trans D₁ D D₁'.
-: swap-lfoc D (↑L D₁) (↑L D₁')
    <- swap D D₁ D₁'.
-: swap-lfoc D (∧⁻L₁ D₁) (∧⁻L₁ D₁')
    <- swap-lfoc D D₁ D₁'.
-: swap-lfoc D (∧⁻L₂ D₁) (∧⁻L₂ D₁')
    <- swap-lfoc D D₁ D₁'.
-: swap-lfoc D (⊃L D₁ D₂) (⊃L D₁ D₂')
    <- swap-lfoc D D₂ D₂'.
-: swap-lfoc D (∀L T D₁) (∀L T D₁')
    <- swap-lfoc D D₁ D₁'.

-: swap (D: Xs ≋ Ys)
    (foc (D₁: hyp⁻ A⁻)
       (sa: stable (c Q⁻ Xs true))
       (D₃: lfoc A⁻ (c Q⁻ Xs true)): conc · (c Q⁻ Xs true))
    (foc D₁ sa D₃': conc · (c Q⁻ Ys true))
    <- swap-lfoc D D₃ D₃'.
-: swap (D: Xs ≋ Ys)
    (eL [d: ⊧ (prim E Zs)] D₁ d)
    (eL [d: ⊧ (prim E Zs)] D₁' d)
    <- ({d} swap D (D₁ d) (D₁' d)).
-: swap (D: Xs ≋ Ys)
    (cL [d: hyp⁺ Q₁ Xs₁] D₁ d)
    (cL [d: hyp⁺ Q₁ Xs₁] D₁' d)
    <- ({d: hyp⁺ Q₁ Xs₁} swap D (D₁ d) (D₁' d)).
-: swap D (↓L ([d] D₁ d)) (↓L ([d] D₁' d))
    <- ({d: hyp⁻ A⁻} swap D (D₁ d) (D₁' d)).
-: swap _ ⊥L ⊥L.
-: swap D (∨L D₁ D₂) (∨L D₁' D₂')
    <- swap D D₁ D₁'
    <- swap D D₂ D₂'.
-: swap D (∃L D₁) (∃L D₁')
    <- ({t:i} swap D (D₁ t) (D₁' t)).
-: swap D (⊤⁺L D₁) (⊤⁺L D₁')
    <- swap D D₁ D₁'.
-: swap D (∧⁺L D₁) (∧⁺L D₁')
    <- swap D D₁ D₁'.

%worlds (gamma)
  (swap _ _ _)
  (swap-lfoc _ _ _)
  (swap-rfoc _ _ _).

%total (D2 E2 F2)
  (swap D1 D2 D3)
  (swap-rfoc E1 E2 E3)
  (swap-lfoc F1 F2 F3).

swap-hyp : Xs ≋ Ys -> (hyp⁺ Q Ys -> conc _Ω Suc) -> (hyp⁺ Q Xs -> conc _Ω Suc) -> type.
swap-hyp-rfoc : Xs ≋ Ys -> (hyp⁺ Q Ys -> rfoc A⁺) -> (hyp⁺ Q Xs -> rfoc A⁺) -> type.
swap-hyp-lfoc : Xs ≋ Ys -> (hyp⁺ Q Ys -> lfoc A⁻ Suc) -> (hyp⁺ Q Xs -> lfoc A⁻ Suc) -> type.
%mode swap-hyp +D +E -F.
%mode swap-hyp-rfoc +D +E -F.
%mode swap-hyp-lfoc +D +E -F.

-: swap-hyp-rfoc _ ([xs] eR D) ([ys] eR D).
-: swap-hyp-rfoc
    (D: Xs ≋ Ys)
    ([xs: hyp⁺ Q Ys] cR (D₁: Us ≋ Vs) (D₂: hyp⁺ Q⁺ Us) : rfoc (c Q⁺ Vs))
    ([ys: hyp⁺ Q Xs] cR D₁ D₂).
-: swap-hyp-rfoc
    (D: Xs ≋ Ys)
    ([xs: hyp⁺ Q⁺ Ys] cR (D₁: Ys ≋ Zs) xs : rfoc (c Q⁺ Zs))
    ([ys: hyp⁺ Q⁺ Xs] cR D₂ ys: rfoc (c Q⁺ Zs))
    <- ≋-trans D D₁ D₂.
-: swap-hyp-rfoc D ([xs] ↓R (D₁ xs)) ([ys] ↓R (D₁' ys))
    <- swap-hyp D D₁ D₁'.
-: swap-hyp-rfoc D ([xs] ∨R₁ (D₁ xs)) ([ys] ∨R₁ (D₁' ys))
    <- swap-hyp-rfoc D D₁ D₁'.
-: swap-hyp-rfoc D ([xs] ∨R₂ (D₁ xs)) ([ys] ∨R₂ (D₁' ys))
    <- swap-hyp-rfoc D D₁ D₁'.
-: swap-hyp-rfoc D ([xs] ∃R T (D₁ xs)) ([ys] ∃R T (D₁' ys))
    <- swap-hyp-rfoc D D₁ D₁'.
-: swap-hyp-rfoc _ ([xs] ⊤⁺R) ([ys] ⊤⁺R).
-: swap-hyp-rfoc D ([xs] ∧⁺R (D₁ xs) (D₂ xs)) ([ys] ∧⁺R (D₁' ys) (D₂' ys))
    <- swap-hyp-rfoc D D₁ D₁'
    <- swap-hyp-rfoc D D₂ D₂'.
-: swap-hyp D ([xs] foc D₁ D₂ (D₃ xs)) ([ys] foc D₁ D₂ (D₃' ys))
    <- swap-hyp-lfoc D D₃ D₃'.
-: swap-hyp (D: Xs ≋ Ys)
    ([xs: hyp⁺ Q Ys] eL [d: ⊧ (prim E Zs)] D₁ d)
    ([ys: hyp⁺ Q Xs] eL [d: ⊧ (prim E Zs)] D₁ d).
-: swap-hyp (D: Xs ≋ Ys)
    ([xs: hyp⁺ Q Ys] cL [d: hyp⁺ Q₁ Xs₁] D₁ d xs)
    ([ys: hyp⁺ Q Xs] cL [d: hyp⁺ Q₁ Xs₁] D₁' d ys)
    <- ({d} swap-hyp D (D₁ d) (D₁' d)).
-: swap-hyp D ([xs] ↓L ([d] D₁ d xs)) ([ys] ↓L ([d] D₁' d ys))
    <- ({d: hyp⁻ A⁻} swap-hyp D (D₁ d) (D₁' d)).
-: swap-hyp _ ([_] ⊥L) ([_] ⊥L).
-: swap-hyp D ([xs] ∨L (D₁ xs) (D₂ xs)) ([ys] ∨L (D₁' ys) (D₂' ys))
    <- swap-hyp D D₁ D₁'
    <- swap-hyp D D₂ D₂'.
-: swap-hyp D ([xs] ∃L (D₁ xs)) ([ys] ∃L (D₁' ys))
    <- ({t:i} swap-hyp D ([xs] D₁ xs t) ([ys] D₁' ys t)).
-: swap-hyp D ([xs] ⊤⁺L (D₁ xs)) ([ys] ⊤⁺L (D₁' ys))
    <- swap-hyp D D₁ D₁'.
-: swap-hyp D ([xs] ∧⁺L (D₁ xs)) ([ys] ∧⁺L (D₁' ys))
    <- swap-hyp D D₁ D₁'.
-: swap-hyp D ([xs] ↑R (D₁ xs)) ([ys] ↑R (D₁' ys))
    <- swap-hyp-rfoc D D₁ D₁'.
-: swap-hyp _ ([_] ⊤⁻R) ([_] ⊤⁻R).
-: swap-hyp D ([xs] ∧⁻R (D₁ xs) (D₂ xs)) ([ys] ∧⁻R (D₁' ys) (D₂' ys))
    <- swap-hyp D D₁ D₁'
    <- swap-hyp D D₂ D₂'.
-: swap-hyp D ([xs] ⊃R (D₁ xs)) ([ys] ⊃R (D₁' ys))
    <- swap-hyp D D₁ D₁'.
-: swap-hyp D ([xs] ∀R ([t] D₁ t xs)) ([ys] ∀R ([t] D₁' t ys))
    <- ({t} swap-hyp D (D₁ t) (D₁' t)).
-: swap-hyp-lfoc D ([_] p⁻ D₁) ([_] p⁻ D₁).
-: swap-hyp-lfoc D ([xs] ↑L (D₁ xs)) ([ys] ↑L (D₁' ys))
    <- swap-hyp D D₁ D₁'.
-: swap-hyp-lfoc D ([xs] ∧⁻L₁ (D₁ xs)) ([ys] ∧⁻L₁ (D₁' ys))
    <- swap-hyp-lfoc D D₁ D₁'.
-: swap-hyp-lfoc D ([xs] ∧⁻L₂ (D₁ xs)) ([ys] ∧⁻L₂ (D₁' ys))
    <- swap-hyp-lfoc D D₁ D₁'.
-: swap-hyp-lfoc D ([xs] ⊃L (D₁ xs) (D₂ xs)) ([ys] ⊃L (D₁' ys) (D₂' ys))
    <- swap-hyp-rfoc D D₁ D₁'
    <- swap-hyp-lfoc D D₂ D₂'.
-: swap-hyp-lfoc D ([xs] ∀L T (D₁ xs)) ([ys] ∀L T (D₁' ys))
    <- swap-hyp-lfoc D D₁ D₁'.

%worlds (gamma)
  (swap-hyp _ _ _)
  (swap-hyp-lfoc _ _ _)
  (swap-hyp-rfoc _ _ _).

%total (D2 E2 F2)
  (swap-hyp D1 D2 D3)
  (swap-hyp-rfoc E1 E2 E3)
  (swap-hyp-lfoc F1 F2 F3).

%{ == Cut admissibility == }%

subst⁺: {A⁺} small
  -> rfoc A⁺
  -> conc (A⁺ , _Ω) (C⁻ true)
  -> conc _Ω (C⁻ true) -> type.
subst⁻: {A⁻} small
  -> conc · (A⁻ true)
  -> lfoc A⁻ (C⁻ true)
  -> stable (C⁻ true)
  -> conc · (C⁻ true) -> type.

%mode subst⁺ +A +S +V +N -N'.
%mode subst⁻ +A +S +N +Sp +St -N'.

rightV:  {A⁻} big
  -> conc · (A⁻ true)
  -> (hyp⁻ A⁻ -> rfoc C⁺)
  -> rfoc C⁺ -> type.
rightN:  {A⁻} big
  -> conc · (A⁻ true)
  -> (hyp⁻ A⁻ -> conc _Ω (C⁻ true))
  -> conc _Ω (C⁻ true) -> type.
rightSp: {A⁻} big
  -> conc · (A⁻ true)
  -> (hyp⁻ A⁻ -> lfoc B⁻ (C⁻ true))
  -> lfoc B⁻ (C⁻ true) -> type.

%mode rightV  +A +S +M +V -N'.
%mode rightN  +A +S +M +N -N'.
%mode rightSp +A +S +M +Sp -N'.

leftN: {A⁺} big
  -> conc _Ω (↑ A⁺ true)
  -> conc (A⁺ , ·) (C⁻ true)
  -> stable (C⁻ true)
  -> conc _Ω (C⁻ true) -> type.
leftSp: {A⁺} big
  -> lfoc B⁻ (↑ A⁺ true)
  -> conc (A⁺ , ·) (C⁻ true)
  -> stable (C⁻ true)
  -> lfoc B⁻ (C⁻ true) -> type.

%mode leftN +A +S +Mi +Ni +Ni' -M'.
%mode leftSp +A +S +Sp +Ni +Sp' -Sp'.

%{ === Principal substitution/cuts === }%

%{ ``(V • N) = N' '' }%

-: subst⁺ (e E Xs) S (eR D) (eL F) (F D).

-: subst⁺ (c Q⁺ Xs) S
    (cR (D: Ws ≋ Xs) (Z: hyp⁺ Q⁺ Ws): rfoc (c Q⁺ Xs))
    (cL ([z': hyp⁺ Q⁺ Xs] N z': conc _Ω (C⁻ true)): conc (c Q⁺ Xs , _Ω) (C⁻ true))
    (N' Z: conc _Ω (C⁻ true))
    <- swap-hyp D N N'.

-: subst⁺ (↓ A⁻) s (↓R M) (↓L N) N'
  <- rightN A⁻ (b s) M N (N': conc _Ω (C⁻ true)).

-: subst⁺ (A⁺ ∨ B⁺) S (∨R₁ V) (∨L N₁ N₂) N'
  <- subst⁺ A⁺ S V N₁ (N': conc _Ω (C⁻ true)).

-: subst⁺ (A⁺ ∨ B⁺) S (∨R₂ V) (∨L N₁ N₂) N'
  <- subst⁺ B⁺ S V N₂ (N': conc _Ω (C⁻ true)).

-: subst⁺ (∃ A⁺) S (∃R T V) (∃L N) N'
  <- subst⁺ (A⁺ T) S V (N T) N'.

-: subst⁺ ⊤⁺ S ⊤⁺R (⊤⁺L N) N.

-: subst⁺ (A⁺ ∧⁺ B⁺) S (∧⁺R V₁ V₂) (∧⁺L N) N'
  <- subst⁺ A⁺ S V₁ N (NB: conc (B⁺ , _Ω) (C⁻ true))
  <- subst⁺ B⁺ S V₂ NB (N': conc _Ω (C⁻ true)).

%{ ``(M • Sp) = N' '' }%

-: subst⁻ (c Q⁻ Xs) S (foc E sa Sp) (p⁻ D) _ D'
    <- swap D (foc E sa Sp) D'.

-: subst⁻ (↑ A⁺) s (foc E s↑ Sp) (↑L N) St (foc E St Sp')
  <- leftSp A⁺ (b s) Sp N St (Sp': lfoc B⁻ (C⁻ true)).

-: subst⁻ (↑ A⁺) S (↑R V) (↑L N) _ N'
  <- subst⁺ A⁺ S V N (N': conc · (C⁻ true)).

-: subst⁻ (A⁺ ⊃ B⁻) S (⊃R N) (⊃L V Sp) St N'
  <- subst⁺ A⁺ S V N (NB: conc · (B⁻ true))
  <- subst⁻ B⁻ S NB Sp St (N': conc · (C⁻ true)).

-: subst⁻ (A⁻ ∧⁻  B⁻) S (∧⁻R M₁ M₂) (∧⁻L₁ Sp) St N'
  <- subst⁻ A⁻ S M₁ Sp St (N': conc · (C⁻ true)).

-: subst⁻ (A⁻ ∧⁻ B⁻) S (∧⁻R M₁ M₂) (∧⁻L₂ Sp) St N'
  <- subst⁻ B⁻ S M₂ Sp St (N': conc · (C⁻ true)).

-: subst⁻ (∀ A⁻) S (∀R [x] M x: conc · ((A⁻ x) true)) (∀L T Sp) St N'
    <- subst⁻ (A⁻ T) S (M T) Sp St (N': conc · (C⁻ true)).

%{ === Rightist substitution (right commutative cuts) === }%

%{ ``[[M/x]]V = V' '' }%

-: rightV A⁻ S M ([x] eR D) (eR D).

-: rightV A⁻ S M ([x] cR D Z) (cR D Z).

-: rightV A⁻ S M ([x] ↓R (N x)) (↓R N')
  <- rightN A⁻ S M ([x] N x) (N': conc · (C⁻ true)).

-: rightV A⁻ S M ([x] ∨R₁ (V x)) (∨R₁ V')
  <- rightV A⁻ S M ([x] V x) (V': rfoc C₁⁺).

-: rightV A⁻ S M ([x] ∨R₂ (V x)) (∨R₂ V')
  <- rightV A⁻ S M ([x] V x) (V': rfoc C₂⁺).

-: rightV A⁻ S M ([x] ∃R T (V x)) (∃R T V')
  <- rightV A⁻ S M ([x] V x) V'.

-: rightV A⁻ S M ([x] ⊤⁺R) ⊤⁺R.

-: rightV A⁻ S M ([x] ∧⁺R (V₁ x) (V₂ x)) (∧⁺R V₁' V₂')
  <- rightV A⁻ S M ([x] V₁ x) (V₁': rfoc C₁⁺)
  <- rightV A⁻ S M ([x] V₂ x) (V₂': rfoc C₂⁺).

%{ ``[[M/x]]N = N' '' }%

-: rightN A⁻ (b s) M ([x] foc x St (Sp x)) N'
  <- rightSp A⁻ (b s) M ([x] Sp x) (Sp': lfoc A⁻ (C⁻ true))
  <- subst⁻ A⁻ s M Sp' St (N': conc · (C⁻ true)).

-: rightN A⁻ S M ([x] foc E' St (Sp x)) (foc E' St Sp')
  <- rightSp A⁻ S M ([x] Sp x) (Sp': lfoc B⁻ (C⁻ true)).

-: rightN A⁻ S M ([x] eL [z] N x z) (eL [z] N' z)
  <- ({z: ⊧ (prim E Xs)} rightN A⁻ S M ([x] N x z) (N' z)).

-: rightN A⁻ S M ([x] cL [z] N x z) (cL [z] N' z)
  <- ({z: hyp⁺ Q⁺ Xs} rightN A⁻ S M ([x] N x z) (N' z: conc _Ω (C⁻ true))).

-: rightN A⁻ S M ([x] ↓L [x'] N x x') (↓L [x'] N' x')
  <- ({x': hyp⁻ B⁻} rightN A⁻ S M ([x] N x x') (N' x': conc _Ω (C⁻ true))).

-: rightN A⁻ S M ([x] ⊥L) ⊥L.

-: rightN A⁻ S M ([x] ∨L (N₁ x) (N₂ x)) (∨L N₁' N₂')
  <- rightN A⁻ S M ([x] N₁ x) (N₁': conc (B₁ , _Ω) (C⁻ true))
  <- rightN A⁻ S M ([x] N₂ x) (N₂': conc (B₂ , _Ω) (C⁻ true)).

-: rightN A⁻ S M ([x] ∃L ([t:i] N x t)) (∃L N')
  <- ({t:i} rightN A⁻ S M ([x] N x t) (N' t)).

-: rightN A⁻ S M ([x] ⊤⁺L (N x)) (⊤⁺L N')
  <- rightN A⁻ S M ([x] N x) (N': conc _Ω (C⁻ true)).

-: rightN A⁻ S M ([x] ∧⁺L (N x)) (∧⁺L N')
  <- rightN A⁻ S M ([x] N x) (N': conc (A⁺ , B⁺ , _Ω) (C⁻ true)).

-: rightN A⁻ S M ([x] ↑R (V x)) (↑R V')
  <- rightV A⁻ S M ([x] V x) (V': rfoc C⁺).

-: rightN A⁻ S M ([x] ⊃R (N x)) (⊃R N')
  <- rightN A⁻ S M ([x] N x) (N': conc (C₁⁺ , ·) (C₂⁻ true)).

-: rightN A⁻ S M ([x] ⊤⁻R) ⊤⁻R.

-: rightN A⁻ S M ([x] ∧⁻R (N₁ x) (N₂ x)) (∧⁻R N₁' N₂')
  <- rightN A⁻ S M ([x] N₁ x) (N₁': conc · (C₁⁻ true))
  <- rightN A⁻ S M ([x] N₂ x) (N₂': conc · (C₂⁻ true)).

-: rightN A⁻ S M ([x:hyp⁻ A⁻] ∀R ([t:i] N x t)) (∀R N')
    <- ({t:i} rightN A⁻ S M ([x'] N x' t) (N' t)).

%{ ``[[M/x]]Sp = Sp' '' }%

-: rightSp A⁻ S M ([x] p⁻ D) (p⁻ D).

-: rightSp A⁻ S M ([x] ↑L (N x)) (↑L N')
  <- rightN A⁻ S M ([x] N x) (N': conc (B⁺ , ·) (C⁻ true)).

-: rightSp A⁻ S M ([x] ⊃L (V x) (Sp x)) (⊃L V' Sp')
  <- rightV A⁻ S M ([x] V x) (V': rfoc B₁⁺)
  <- rightSp A⁻ S M ([x] Sp x) (Sp': lfoc B₂⁻ (C⁻ true)).

-: rightSp A⁻ S M ([x] ∧⁻L₁ (Sp x)) (∧⁻L₁ Sp')
  <- rightSp A⁻ S M ([x] Sp x) (Sp': lfoc B₁⁻ (C⁻ true)).

-: rightSp A⁻ S M ([x] ∧⁻L₂ (Sp x)) (∧⁻L₂ Sp')
  <- rightSp A⁻ S M ([x] Sp x) (Sp': lfoc B₂⁻ (C⁻ true)).

-: rightSp A⁻ S M ([x] ∀L T (Sp x)) (∀L T Sp')
  <- rightSp A⁻ S M ([x] Sp x) Sp'.


%{ === Leftist substitution (left commutative cuts) === }%

%{ ``<<M>>N = M' '' }%

-: leftN A⁺ S (foc E _ Sp) N St (foc E St Sp')
  <- leftSp A⁺ S Sp N St (Sp': lfoc B⁻ (C⁻ true)).

-: leftN A⁺ S (eL M) N St (eL M')
  <- ({z: ⊧ (prim E Xs)} leftN A⁺ S (M z) N St (M' z: conc _Ω (C⁻ true))).

-: leftN A⁺ S (cL [z] M z) N St (cL [z] M' z)
  <- ({z: hyp⁺ Q⁺ Xs} leftN A⁺ S (M z) N St (M' z: conc _Ω (C⁻ true))).

-: leftN A⁺ S (↓L [x'] M x') N St (↓L [x'] M' x')
  <- ({x': hyp⁻ B⁻} leftN A⁺ S (M x') N St (M' x': conc _Ω (C⁻ true))).

-: leftN A⁺ S ⊥L N St ⊥L.

-: leftN A⁺ S (∨L M₁ M₂) N St (∨L M₁' M₂')
  <- leftN A⁺ S M₁ N St (M₁': conc (B₁⁺ , _Ω) (C⁻ true))
  <- leftN A⁺ S M₂ N St (M₂': conc (B₂⁺ , _Ω) (C⁻ true)).

-: leftN A⁺ S (∃L M) N St (∃L M')
  <- ({t} leftN A⁺ S (M t) N St (M' t)).

-: leftN A⁺ S (⊤⁺L M) N St (⊤⁺L M')
  <- leftN A⁺ S M N St (M': conc _Ω (C⁻ true)).

-: leftN A⁺ S (∧⁺L M) N St (∧⁺L M')
  <- leftN A⁺ S M N St (M': conc (B₁⁺ , B₂⁺ , _Ω) (C⁻ true)).

-: leftN A⁺ (b s) (↑R V) N St N'
  <- subst⁺ A⁺ s V N (N': conc · (C⁻ true)).

%{ ``<<Sp>>N = Sp' '' }%

-: leftSp A⁺ S (↑L M) N St (↑L M')
  <- leftN A⁺ S M N St (M': conc (B⁺ , ·) (C⁻ true)).

-: leftSp A⁺ S (⊃L V Sp) N St (⊃L V Sp')
  <- leftSp A⁺ S Sp N St (Sp': lfoc B₂⁻ (C⁻ true)).

-: leftSp A⁺ S (∧⁻L₁ Sp) N St (∧⁻L₁ Sp')
  <- leftSp A⁺ S Sp N St (Sp': lfoc B₁⁻ (C⁻ true)).

-: leftSp A⁺ S (∧⁻L₂ Sp) N St (∧⁻L₂ Sp')
  <- leftSp A⁺ S Sp N St (Sp': lfoc B₂⁻ (C⁻ true)).

-: leftSp A⁺ S (∀L T Sp) N St (∀L T Sp')
  <- leftSp A⁺ S Sp N St Sp'.

%{ === Wrap-up === }%

%worlds (gamma)
  (subst⁻ _ _ _ _ _ _)
  (subst⁺ _ _ _ _ _)
  (rightN _ _ _ _ _ )
  (rightV _ _ _ _ _)
  (rightSp _ _ _ _ _)
  (leftN _ _ _ _ _ _)
  (leftSp _ _ _ _ _ _).

%{ With the exception of the "big/small" metric that allows the leftist and
rightist substitutions to call principal substitutions at the same type, this
is the usual induction metric for structrual cut elimination arguments. }%

%total
  {(A1 A2 A3 A4 A5 A6 A7)
   {(S1 S2 S3 S4 S5 S6 S7)
    [(MN MV MSp MP VP ML SpL)
     (N V Sp SpP NiP NiL1 NiL2)]}}
  (subst⁻  A1 S1 MP  SpP _ _)
  (subst⁺  A2 S2 VP  NiP _)
  (rightN  A3 S3 MN  N _)
  (rightV  A4 S4 MV  V _)
  (rightSp A5 S5 MSp Sp _)
  (leftN   A6 S6 ML  NiL1 _ _)
  (leftSp  A7 S7 SpL NiL2 _ _).

%{ The following slightly simpler induction metric also works, however,
emphasizing that the "derivation" metric matters not at all in the principal
cases, that the rightist substitutions are structurally inductive over the
second given derivation (the "right" derivation) and that the leftist
substitutions are structurally inductive over the first given derivation (the
"left" derivation). }%

%total
  {(A1 A2 A3 A4 A5 A6 A7)
   {(S1 S2 S3 S4 S5 S6 S7)
     (N V Sp S1 S2 ML SpL)}}
  (subst⁻  A1 S1 _   _ _ _)
  (subst⁺  A2 S2 _   _ _)
  (rightN  A3 S3 _   N _)
  (rightV  A4 S4 _   V _)
  (rightSp A5 S5 _   Sp _)
  (leftN   A6 S6 ML  _ _ _)
  (leftSp  A7 S7 SpL _ _ _).

%{ == Expansion == }%

expand⁻: {A⁻} ({γ} stable γ -> lfoc A⁻ γ -> conc · γ)
      -> conc · (A⁻ true)
      -> type.

expand⁺: {A⁺} (rfoc A⁺ -> conc _Ω Suc)
      -> conc (A⁺ , _Ω) Suc
      -> type.

%mode expand⁻ +A⁻ +Sp -N.
%mode expand⁺ +A⁺ +N -Ni.

%{ ``η(v.N) = N' '' }%

-: expand⁺ (e E Xs) ([v: rfoc (e E Xs)] N v) (eL [x] N (eR x)).

-: expand⁺ (c Q⁺ Xs)
    ([v: rfoc (c Q⁺ Xs)] N v)
    (cL [x: hyp⁺ Q⁺ Xs] (N (cR D x)))
    <- ≋-refl Xs D.

-: expand⁺ (↓ A⁻) ([v: rfoc (↓ A⁻)] N v)
    (↓L [x: hyp⁻ A⁻] N (↓R (N' x)))
  <- ({x: hyp⁻ A⁻}
       expand⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] foc x st sp)
         (N' x: conc · (A⁻ true))).

-: expand⁺ ⊥ ([v: rfoc ⊥] N v) ⊥L.

-: expand⁺ (A⁺ ∨ B⁺) ([v: rfoc (A⁺ ∨ B⁺)] N v) (∨L N₁ N₂)
  <- expand⁺ A⁺ ([v: rfoc A⁺] N (∨R₁ v)) (N₁: conc (A⁺ , _Ω) Suc)
  <- expand⁺ B⁺ ([v: rfoc B⁺] N (∨R₂ v)) (N₂: conc (B⁺ , _Ω) Suc).

-: expand⁺ (∃ A⁺) ([v: rfoc (∃ A⁺)] N v) (∃L N')
  <- ({t} expand⁺ (A⁺ t) ([v: rfoc (A⁺ t)] N (∃R t v)) (N' t)).

-: expand⁺ ⊤⁺ ([v: rfoc ⊤⁺] N v) (⊤⁺L (N ⊤⁺R)).

-: expand⁺ (A⁺ ∧⁺ B⁺) ([v: rfoc (A⁺ ∧⁺ B⁺)] N v) (∧⁺L N₂)
  <- ({v₁: rfoc A⁺}
       expand⁺ B⁺ ([v₂: rfoc B⁺] N (∧⁺R v₁ v₂)) (N₁ v₁: conc (B⁺ , _Ω) Suc))
  <- expand⁺ A⁺ ([v₁: rfoc A⁺] N₁ v₁) (N₂: conc (A⁺ , B⁺ , _Ω) Suc).

%{ ``η(s.N) = N' '' }%

-: expand⁻ (c Q⁻ Xs)
    ([γ][st][sp: lfoc (c Q⁻ Xs) γ] N γ st sp)
    (N _ sa (p⁻ D))
    <- ≋-refl Xs D.

-: expand⁻ (↑ A⁺) ([γ][st][sp: lfoc (↑ A⁺) γ] N γ st sp) (N _ s↑ (↑L N'))
  <- expand⁺ A⁺ ([v: rfoc A⁺] ↑R v) (N': conc (A⁺ , ·) (↑ A⁺ true)).

-: expand⁻ ⊤⁻ ([γ][st][sp: lfoc ⊤⁻ γ] N γ st sp) ⊤⁻R.

-: expand⁻ (A⁻ ∧⁻ B⁻) ([γ][st][sp: lfoc (A⁻ ∧⁻ B⁻) γ] N γ st sp) (∧⁻R N₁ N₂)
  <- expand⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] N γ st (∧⁻L₁ sp))
       (N₁: conc · (A⁻ true))
  <- expand⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] N γ st (∧⁻L₂ sp))
       (N₂: conc · (B⁻ true)).

-: expand⁻ (A⁺ ⊃ B⁻) ([γ][st][sp: lfoc (A⁺ ⊃ B⁻) γ] N γ st sp) (⊃R N₂)
  <- ({v: rfoc A⁺}
       expand⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] N γ st (⊃L v sp))
         (N₁ v: conc · (B⁻ true)))
  <- expand⁺ A⁺ ([v: rfoc A⁺] N₁ v) (N₂: conc (A⁺ , ·) (B⁻ true)).

-: expand⁻ (∀ A⁻) ([γ][st][sp: lfoc (∀ A⁻) γ] N γ st sp) (∀R N')
  <- ({t:i} expand⁻ (A⁻ t) ([γ][st][sp: lfoc (A⁻ t) γ] N γ st (∀L t sp))
      (N' t: conc · ((A⁻ t) true))).

%worlds (aleph)
  (expand⁺ _ _ _)
  (expand⁻ _ _ _).
%total (A⁺ A⁻)
  (expand⁺ A⁺ _ _)
  (expand⁻ A⁻ _ _).

%{ Identity is a corollary, though not one we'll actually use: }%

identity: (hyp⁻ A⁻ -> conc · (A⁻ true)) -> type.
%mode +{A⁻} -{N: hyp⁻ A⁻ -> conc · (A⁻ true)} identity N.

-: identity N
  <- ({x: hyp⁻ A⁻}
       expand⁻ A⁻
         ([γ][st][sp: lfoc A⁻ γ] foc x st sp)
         (N x: conc · (A⁻ true))).

%worlds (gamma) (identity _).
%total [] (identity _).


%{ == Unfocused admissibility == }%

%{ The key lemmas for establishing the completeness of the focused sequent
calculus are the "unfocused admissibility" lemmas, which establish that the
normal rules of the sequent calculus are usable in the context of the focused
calculus.

These lemmas are all provable by use of the cut and identity principles, though
the proofs are hardly straightfoward. The ``shift'' and ``unshift'' lemmas
simplify matters somewhat, though shift is simply derivable. }%

shift: conc · (A⁻ true) -> conc · (↑ (↓ A⁻) true) -> type.
%mode shift +D -E.

-: shift N (↑R (↓R N)).

%worlds (gamma) (shift _ _).
%total [] (shift _ _).

unshift: conc · (↑ (↓ A⁻) true) -> conc · (A⁻ true) -> type.
%mode unshift +D -E.

-: unshift N M
  <- ({x: hyp⁻ (↑ (↓ A⁻))}
       expand⁻ A⁻
         ([γ][st][sp: lfoc A⁻ γ] foc x st (↑L (↓L [x'] foc x' st sp)))
         (N' x: conc · (A⁻ true)))
  <- rightN _ (b s) N ([x: hyp⁻ (↑ (↓ A⁻))] N' x) (M: conc · (A⁻ true)).

%worlds (gamma) (unshift _ _).
%total [] (unshift _ _).


%{ ==== Initial rules ==== }%

adm-init⁻: (Xs ≋ Ys -> hyp⁻ (c Q Xs) -> conc · (c Q Ys true)) -> type.
%mode +{Q} +{Xs} +{Ys} -{N': Xs ≋ Ys -> hyp⁻ (c Q Xs) -> conc · (c Q Ys true)} adm-init⁻ N'.

-: adm-init⁻ ([d: Xs ≋ Ys][x: hyp⁻ (c Q Xs)] foc x sa (p⁻ d)).

%worlds (gamma) (adm-init⁻ _).
%total [] (adm-init⁻ _).

adm-init₁⁺: (Xs ≋ Ys -> hyp⁻ (↑ (c Q Xs)) -> conc · (↑ (c Q Ys) true)) -> type.
%mode +{Q} +{Xs} +{Ys} -{N': Xs ≋ Ys -> hyp⁻ (↑ (c Q Xs)) -> conc · (↑ (c Q Ys) true)} adm-init₁⁺ N'.

-: adm-init₁⁺ ([d: Xs ≋ Ys][x: hyp⁻ (↑ (c Q Xs))] foc x s↑ (↑L (cL [z] ↑R (cR d z)))).

%worlds (gamma) (adm-init₁⁺ _).
%total [] (adm-init₁⁺ _).

adm-init₂⁺: (Xs ≋ Ys -> hyp⁺ Q Xs -> conc · (↑ (c Q Ys) true)) -> type.
%mode +{Q} +{Xs} +{Ys} -{N': Xs ≋ Ys -> hyp⁺ Q Xs -> conc · (↑ (c Q Ys) true)} adm-init₂⁺ N'.

-: adm-init₂⁺ ([d][z: hyp⁺ Q Xs] ↑R (cR d z)).

%worlds (gamma) (adm-init₂⁺ _).
%total [] (adm-init₂⁺ _).


%{ ==== Disjunction ==== }%

adm-⊥L: (hyp⁻ (↑ ⊥) -> conc · (C⁻ true)) -> type.
%mode +{C⁻} -{N': hyp⁻ (↑ ⊥) -> conc · (C⁻ true)} adm-⊥L N'.

-: adm-⊥L N'
  <- {x: hyp⁻ (↑ ⊥)} unshift (foc x s↑ (↑L ⊥L)) (N' x: conc · (C⁻ true)).

%worlds (gamma) (adm-⊥L _).
%total [] (adm-⊥L _).

adm-∨R₁: conc · (↑ A⁺ true)
       -> conc · (↑ (A⁺ ∨ B⁺) true)
       -> type.
%mode +{A⁺} +{B⁺} +{N₁} -{N': conc · (↑ (A⁺ ∨ B⁺) true)} adm-∨R₁ N₁ N'.

-: adm-∨R₁ (N₁: conc · (↑ A⁺ true)) N'
  <- expand⁺ A⁺ ([v: rfoc A⁺] ↑R (∨R₁ v))
       (NId₁: conc (A⁺ , ·) (↑ (A⁺ ∨ B⁺) true))
  <- subst⁻ _ s N₁ (↑L NId₁) s↑
       (N': conc · (↑ (A⁺ ∨ B⁺) true)).

%worlds (gamma) (adm-∨R₁ _ _).
%total [] (adm-∨R₁ _ _).

adm-∨R₂: conc · (↑ B⁺ true)
       -> conc · (↑ (A⁺ ∨ B⁺) true)
       -> type.
%mode +{A⁺} +{B⁺} +{N₂} -{N': conc · (↑ (A⁺ ∨ B⁺) true)} adm-∨R₂ N₂ N'.

-: adm-∨R₂ (N₂: conc · (↑ B⁺ true)) N'
  <- expand⁺ B⁺ ([v: rfoc B⁺] ↑R (∨R₂ v))
       (NId₂: conc (B⁺ , ·) (↑ (A⁺ ∨ B⁺) true))
  <- subst⁻ _ s N₂ (↑L NId₂) s↑
       (N': conc · (↑ (A⁺ ∨ B⁺) true)).

%worlds (gamma) (adm-∨R₂ _ _).
%total [] (adm-∨R₂ _ _).


adm-eR: ⊧ (prim E Xs) -> conc · (↑ (e E Xs) true) -> type.
%mode adm-eR +D₁ -D₂.
-: adm-eR (X: ⊧ (prim E Xs)) (↑R (eR X)).
%worlds (gamma) (adm-eR _ _).
%total [] (adm-eR _ _).

%{ Note that C⁻ is not stable in general,
   so many invertible rules may apply to C before we can focus on
   ↑ (e E).  If we had a proof that C is stable, then the proof term would be
   adm-eL ([x: ⊧ (prim E)] D₁ x: conc · (C⁻ true)) ([h: hyp⁻ (↑ (e E))] foc h ? (↑L (eL D₁))).
   The solution is to double-shift C, which is stable, then unshift it at the end.

Have:
  h                      :  hyp⁻ (↑ (e E))
  D₁                     :  ⊧ (prim E) -> conc · (C⁻ true)
  D₂ (using shift)       :  ⊧ (prim E) -> conc · (↑ (↓ C⁻) true)
  eL D₁                  : conc (e E , ·) (C⁻ true)
  eL D₂                  : conc (e E , ·) (↑ (↓ C⁻) true)
  ↑L (eL D₁)             :  lfoc (↑ (e E)) (C⁻ true)
  ↑L (eL D₂)             :  lfoc (↑ (e E)) (↑ (↓ C⁻) true)

  ? : stable (C⁻ true)
  s↑ : stable (↑ (↓ C⁻))

  foc h s↑ (↑L (eL D₂))   :  conc · (↑ (↓ C⁻) true)
  unshift (foc h s↑ (↑L (eL D₂)))  :  conc · (C⁻ true)
}%
adm-eL: (⊧ (prim E Xs) -> conc · (C⁻ true))
         -> (hyp⁻ (↑ (e E Xs)) -> conc · (C⁻ true))
         -> type.
%mode adm-eL +D₁ -D₂.

-: adm-eL (D₁: ⊧ (prim E Xs) -> conc · (C⁻ true))
          ([h: hyp⁻ (↑ (e E Xs))] D h)
    <- ({x: ⊧ (prim E Xs)} shift (D₁ x) (D₂ x))
    <- ({h: hyp⁻ (↑ (e E Xs))} unshift (foc h s↑ (↑L (eL D₂))) (D h)).

%worlds (gamma) (adm-eL _ _).
%total [] (adm-eL _ _).

adm-∨L: (hyp⁻ (↑ A⁺) -> conc · (C⁻ true))
      -> (hyp⁻ (↑ B⁺) -> conc · (C⁻ true))
      -> (hyp⁻ (↑ (A⁺ ∨ B⁺)) -> conc · (C⁻ true))
      -> type.
%mode adm-∨L +N₁ +N₂ -N'.

-: adm-∨L (N₁: hyp⁻ (↑ A⁺) -> conc · (C⁻ true))
     (N₂: hyp⁻ (↑ B⁺) -> conc · (C⁻ true)) N'
  <- ({x₁: hyp⁻ (↑ A⁺)} shift (N₁ x₁) (NShift₁ x₁: conc · (↑ (↓ C⁻) true)))
  <- ({x₂: hyp⁻ (↑ B⁺)} shift (N₂ x₂) (NShift₂ x₂: conc · (↑ (↓ C⁻) true)))
  <- expand⁺ A⁺
       ([v₁: rfoc A⁺] ↑R (∨R₁ (↓R (↑R v₁))))
       (NId₁: conc (A⁺ , ·) (↑ (↓ (↑ A⁺) ∨ ↓ (↑ B⁺)) true))
  <- expand⁺ B⁺
       ([v₂: rfoc B⁺] ↑R (∨R₂ (↓R (↑R v₂))))
       (NId₂: conc (B⁺ , ·) (↑ (↓ (↑ A⁺) ∨ ↓ (↑ B⁺)) true))
  <- ({x: hyp⁻ (↑ (A⁺ ∨ B⁺))}
       leftN _ (b s) (∨L NId₁ NId₂) (∨L (↓L NShift₁) (↓L NShift₂)) s↑
         (NShift x: conc (A⁺ ∨ B⁺ , ·) (↑ (↓ C⁻) true)))
  <- ({x: hyp⁻ (↑ (A⁺ ∨ B⁺))}
       unshift (foc x s↑ (↑L (NShift x))) (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-∨L _ _ _).
%total [] (adm-∨L _ _ _).


%{ ==== Positive conjunction ==== }%

adm-⊤⁺R: conc · (↑ ⊤⁺ true) -> type.
%mode adm-⊤⁺R -N'.

-: adm-⊤⁺R (↑R ⊤⁺R).

%worlds (gamma) (adm-⊤⁺R _).
%total [] (adm-⊤⁺R _).

adm-⊤⁺L: conc · (C⁻ true)
       -> (hyp⁻ (↑ ⊤⁺) -> conc · (C⁻ true))
       -> type.
%mode adm-⊤⁺L +N₁ -N.

-: adm-⊤⁺L N₁ N'
  <- shift N₁ (NShift: conc · (↑ (↓ C⁻) true))
  <- ({x: hyp⁻ (↑ ⊤⁺)}
       unshift (foc x s↑ (↑L (⊤⁺L NShift))) (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-⊤⁺L _ _).
%total [] (adm-⊤⁺L _ _).

adm-∧⁺R: conc · (↑ A⁺ true)
        -> conc · (↑ B⁺ true)
        -> conc · (↑ (A⁺ ∧⁺ B⁺) true)
        -> type.
%mode adm-∧⁺R +N₁ +N₂ -N.

-: adm-∧⁺R (N₁: conc · (↑ A⁺ true)) (N₂: conc · (↑ B⁺ true)) N'
  <- ({v₁: rfoc A⁺}
       expand⁺ B⁺ ([v₂: rfoc B⁺] (↑R (∧⁺R v₁ v₂)))
         (NIdA v₁: conc (B⁺ , ·) (↑ (A⁺ ∧⁺ B⁺) true)))
  <- ({x₂: hyp⁻ (↑ B⁺)}
       expand⁺ A⁺ ([v₁: rfoc A⁺] foc x₂ s↑ (↑L (NIdA v₁)))
         (NId x₂: conc (A⁺ , ·) (↑ (A⁺ ∧⁺ B⁺) true)))
  <- ({x₂: hyp⁻ (↑ B⁺)}
       subst⁻ _ s N₁ (↑L (NId x₂)) s↑
         (NB x₂: conc · (↑ (A⁺ ∧⁺ B⁺) true)))
  <- rightN _ (b s) N₂ ([x₂: hyp⁻ (↑ B⁺)] NB x₂)
       (N': conc · (↑ (A⁺ ∧⁺ B⁺) true)).

%worlds (gamma) (adm-∧⁺R _ _ _).
%total [] (adm-∧⁺R _ _ _).

adm-∧⁺L: (hyp⁻ (↑ A⁺) -> hyp⁻ (↑ B⁺) -> conc · (C⁻ true))
        -> (hyp⁻ (↑ (A⁺ ∧⁺ B⁺)) -> conc · (C⁻ true))
        -> type.
%mode adm-∧⁺L +N₁ -N.

-: adm-∧⁺L (N₁: hyp⁻ (↑ A⁺) -> hyp⁻ (↑ B⁺) -> conc · (C⁻ true)) N'
  <- ({x₁: hyp⁻ (↑ A⁺)}{x₂: hyp⁻ (↑ B⁺)}
       shift (N₁ x₁ x₂) (NShift₁ x₁ x₂: conc · (↑ (↓ C⁻) true)))
  <- ({v₁: rfoc A⁺}
       expand⁺ B⁺ ([v₂: rfoc B⁺] ↑R (∧⁺R (↓R (↑R v₁)) (↓R (↑R v₂))))
         (NIdA v₁: conc (B⁺ , ·) (↑ (↓ (↑ A⁺) ∧⁺ ↓ (↑ B⁺)) true)))
  <- expand⁺ A⁺ ([v₁: rfoc A⁺] NIdA v₁)
       (NId: conc (A⁺ , B⁺ , ·) (↑ (↓ (↑ A⁺) ∧⁺ ↓ (↑ B⁺)) true))
  <- ({x: hyp⁻ (↑ (A⁺ ∧⁺ B⁺))}
       leftN _ (b s) (∧⁺L NId) (∧⁺L (↓L [x₁] ↓L [x₂] NShift₁ x₁ x₂)) s↑
         (NShift x: conc (A⁺ ∧⁺ B⁺ , ·) (↑ (↓ C⁻) true)))
  <- ({x: hyp⁻ (↑ (A⁺ ∧⁺ B⁺))}
       unshift (foc x s↑ (↑L (NShift x))) (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-∧⁺L _ _).
%total [] (adm-∧⁺L _ _).


%{ ==== Implication ==== }%

adm-⊃R: (hyp⁻ (↑ A⁺) -> conc · (B⁻ true))
       -> conc · (A⁺ ⊃ B⁻ true)
       -> type.
%mode adm-⊃R +N₁ -N.

-: adm-⊃R (N₁: hyp⁻ (↑ A⁺) -> conc · (B⁻ true)) N'
  <- ({x: hyp⁻ (↓ (↑ A⁺) ⊃ B⁻)}{v: rfoc A⁺}
       expand⁻ B⁻
         ([γ][st][sp: lfoc B⁻ γ]
           foc x st (⊃L (↓R (↑R v)) sp))
         (NId₁ x v: conc · (B⁻ true)))
  <- ({x: hyp⁻ (↓ (↑ A⁺) ⊃ B⁻)}
       expand⁺ A⁺
         ([v: rfoc A⁺] NId₁ x v)
         (NId x: conc (A⁺ , ·) (B⁻ true)))
  <- rightN _ (b s) (⊃R (↓L [x₁: hyp⁻ (↑ A⁺)] N₁ x₁))
       ([x: hyp⁻ (↓ (↑ A⁺) ⊃ B⁻)] ⊃R (NId x))
       (N': conc · (A⁺ ⊃ B⁻ true)).

%worlds (gamma) (adm-⊃R _ _).
%total [] (adm-⊃R _ _).

adm-⊃L: conc · (↑ A⁺ true)
       -> (hyp⁻ B⁻ -> conc · (C⁻ true))
       -> (hyp⁻ (A⁺ ⊃ B⁻) -> conc · (C⁻ true))
       -> type.
%mode adm-⊃L +N₁ +N₂ -N'.

-: adm-⊃L (N₁: conc · (↑ A⁺ true)) (N₂: hyp⁻ B⁻ -> conc · (C⁻ true)) N'
  <- ({x₂: hyp⁻ B⁻} shift (N₂ x₂) (NShift₂ x₂: conc · (↑ (↓ C⁻) true)))
  <- ({x: hyp⁻ (A⁺ ⊃ B⁻)} {v: rfoc A⁺}
       expand⁻ B⁻
         ([γ][st][sp: lfoc B⁻ γ] foc x st (⊃L v sp))
         (NId₁ x v: conc · (B⁻ true)))
  <- ({x: hyp⁻ (A⁺ ⊃ B⁻)}
       expand⁺ A⁺ ([v: rfoc A⁺] ↑R (↓R (NId₁ x v)))
         (NId₂ x: conc (A⁺ , ·) (↑ (↓ B⁻) true)))
  <- ({x: hyp⁻ (A⁺ ⊃ B⁻)}
       subst⁻ _ s N₁ (↑L (NId₂ x)) s↑
         (NA x: conc · (↑ (↓ B⁻) true)))
  <- ({x: hyp⁻ (A⁺ ⊃ B⁻)}
       subst⁻ _ s (NA x) (↑L (↓L NShift₂)) s↑
         (NShift x: conc · (↑ (↓ C⁻) true)))
  <- ({x: hyp⁻ (A⁺ ⊃ B⁻)}
       unshift (NShift x) (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-⊃L _ _ _).
%total [] (adm-⊃L _ _ _).


%{ ==== Negative conjunction ==== }%

adm-⊤⁻R: conc · (⊤⁻ true) -> type.
%mode adm-⊤⁻R -N'.

-: adm-⊤⁻R ⊤⁻R.

%worlds (gamma) (adm-⊤⁻R _).
%total [] (adm-⊤⁻R _).

adm-∧⁻R: conc · (A⁻ true)
        -> conc · (B⁻ true)
        -> conc · (A⁻ ∧⁻ B⁻ true)
        -> type.
%mode adm-∧⁻R +N₁ +N₂ -N'.

-: adm-∧⁻R N₁ N₂ (∧⁻R N₁ N₂).

%worlds (gamma) (adm-∧⁻R _ _ _).
%total [] (adm-∧⁻R _ _ _).

adm-∧⁻L₁: (hyp⁻ A⁻ -> conc · (C⁻ true))
         -> (hyp⁻ (A⁻ ∧⁻ B⁻) -> conc · (C⁻ true))
         -> type.
%mode +{A⁻} +{B⁻} +{C⁻} +{N₁} -{N': hyp⁻ (A⁻ ∧⁻ B⁻) -> conc · (C⁻ true)}
  adm-∧⁻L₁ N₁ N'.

-: adm-∧⁻L₁ (N₁: hyp⁻ A⁻ -> conc · (C⁻ true)) N'
  <- ({x: hyp⁻ (A⁻ ∧⁻ B⁻)}
       expand⁻ A⁻ ([γ][st][sp: lfoc A⁻ γ] foc x st (∧⁻L₁ sp))
         (NId x: conc · (A⁻ true)))
  <- ({x: hyp⁻ (A⁻ ∧⁻ B⁻)}
       rightN _ (b s) (NId x) ([x₁: hyp⁻ A⁻] N₁ x₁)
         (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-∧⁻L₁ _ _).
%total [] (adm-∧⁻L₁ _ _).

adm-∧⁻L₂: (hyp⁻ B⁻ -> conc · (C⁻ true))
         -> (hyp⁻ (A⁻ ∧⁻ B⁻) -> conc · (C⁻ true))
         -> type.
%mode +{A⁻} +{B⁻} +{C⁻} +{N₁} -{N': hyp⁻ (A⁻ ∧⁻ B⁻) -> conc · (C⁻ true)}
  adm-∧⁻L₂ N₁ N'.

-: adm-∧⁻L₂ (N₂: hyp⁻ B⁻ -> conc · (C⁻ true)) N'
  <- ({x: hyp⁻ (A⁻ ∧⁻ B⁻)}
       expand⁻ B⁻ ([γ][st][sp: lfoc B⁻ γ] foc x st (∧⁻L₂ sp))
         (NId x: conc · (B⁻ true)))
  <- ({x: hyp⁻ (A⁻ ∧⁻ B⁻)}
       rightN _ (b s) (NId x) ([x₁: hyp⁻ B⁻] N₂ x₁)
         (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-∧⁻L₂ _ _).
%total [] (adm-∧⁻L₂ _ _).

%{ ==== Universal quantification ==== }%

adm-∀R: ({t} conc · ((A⁻ t) true)) -> conc · ((∀ A⁻) true) -> type.
%mode adm-∀R +N -N'.

-: adm-∀R N (∀R N).

%worlds (gamma) (adm-∀R _ _).
%total [] (adm-∀R _ _).

adm-∀L: (hyp⁻ (A⁻ T) -> conc · (C⁻ true))
         -> (hyp⁻ (∀ A⁻) -> conc · (C⁻ true))
         -> type.
%mode adm-∀L +N -N'.

-: adm-∀L (N: hyp⁻ (A⁻ T) -> conc · (C⁻ true)) N'
  <- ({x: hyp⁻ (∀ A⁻)}
       expand⁻ (A⁻ T) ([γ][st][sp: lfoc (A⁻ T) γ] foc x st (∀L T sp))
         (NId x: conc · ((A⁻ T) true)))
  <- ({x: hyp⁻ (∀ A⁻)}
       rightN _ (b s) (NId x) ([x₁: hyp⁻ (A⁻ T)] N x₁)
         (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-∀L _ _).
%total [] (adm-∀L _ _).

%{ ==== Existential quantification ==== }%

adm-∃R: conc · (↑ (A⁺ T) true)
         -> conc · (↑ (∃ A⁺) true)
         -> type.
%mode adm-∃R +N -N'.

-: adm-∃R N N'
  <- expand⁺ (A⁺ T) ([v: rfoc (A⁺ T)] ↑R (∃R T v)) (Nid: conc ((A⁺ T), ·) (↑ (∃ A⁺) true))
  <- subst⁻ _ s N (↑L Nid) s↑ (N').

%worlds (gamma) (adm-∃R _ _ ).
%total [] (adm-∃R _ _).

adm-∃L: ({t:i} hyp⁻ (↑ (A⁺ t)) -> conc · (C⁻ true))
         -> (hyp⁻ (↑ (∃ A⁺)) -> conc · (C⁻ true))
         -> type.
%mode adm-∃L +N -N'.

-: adm-∃L (N: {t:i} hyp⁻ (↑ (A⁺ t)) -> conc · (C⁻ true)) N'
  <- ({t:i}{x: hyp⁻ (↑ (A⁺ t))} shift (N t x) (NShift₁ t x: conc · (↑ (↓ C⁻) true)))
  <- ({t:i} expand⁺ (A⁺ t)
       ([v: rfoc (A⁺ t)] ↑R (∃R t (↓R (↑R v))))
       (NId t: conc ((A⁺ t) , ·) ((↑ (∃ [t] ↓ (↑ (A⁺ t)))) true)))
  <- ({x: hyp⁻ (↑ (∃ A⁺))}
       leftN _ (b s) (∃L NId) (∃L ([t] ↓L (NShift₁ t))) s↑
         (NShift x: conc ((∃ A⁺) , ·) (↑ (↓ C⁻) true)))
  <- ({x: hyp⁻ (↑ (∃ A⁺))}
       unshift (foc x s↑ (↑L (NShift x))) (N' x: conc · (C⁻ true))).

%worlds (gamma) (adm-∃L _ _).
%total [] (adm-∃L _ _).

%{ ==== Shift removal ==== }%

shifthyp: (hyp⁻ A⁻ -> conc · (C⁻ true))
        -> (hyp⁻ (↑ (↓ A⁻)) -> conc · (C⁻ true)) -> type.
-: shifthyp (N₁: hyp⁻ A⁻ -> conc · (C⁻ true)) N'
  <- ({x₁: hyp⁻ A⁻} shift (N₁ x₁) (NShift x₁))
  <- ({x: hyp⁻ (↑ (↓ A⁻))} unshift (foc x s↑ (↑L (↓L NShift)))
       (N' x: conc · (C⁻ true))).
%mode shifthyp +N₁ -N'.
%worlds (gamma) (shifthyp _ _).
%total [] (shifthyp _ _).

%{ == Unfocused system == }%

%{ === Syntax === }%

prop: type. %name prop P.
uatom: type.
ee: eatom -> args -> prop.
a: atom P -> args -> prop.
ff: prop.
or: prop -> prop -> prop.
tt: prop.
and: prop -> prop -> prop.
imp: prop -> prop -> prop.
all: (i -> prop) -> prop.
ex: (i -> prop) -> prop.

@ : atom P -> i -> prop = [p][x] a p (x ⋆ ●). %infix none 21 @.

props: type. %name props _Ψ.
○: props.
;: prop -> props -> props. %infix right 3 ;.

%{ The judgment ``t P A'' relates unpolarized propositions ``P'' and polarized
propositions ``A''. The judgment can be effectively run as an erasure function
from polarized to unpolarized propositions. }%

t: typ P -> prop -> type. %name t Trans.

te: t (e E Xs) (ee E Xs).
tc: t (c Q Xs) (a Q Xs).

t↑: t A⁺ P -> t (↑ A⁺) P.
t⊥: t ⊥ ff.
t∨: t A⁺ P₁ -> t B⁺ P₂ -> t (A⁺ ∨ B⁺) (or P₁ P₂).
t⊤⁺: t ⊤⁺ tt.
t∧⁺: t A⁺ P₁ -> t B⁺ P₂ -> t (A⁺ ∧⁺ B⁺) (and P₁ P₂).

t↓: t A⁻ P -> t (↓ A⁻) P.
t⊤⁻: t ⊤⁻ tt.
t∧⁻: t A⁻ P₁ -> t B⁻ P₂ -> t (A⁻ ∧⁻ B⁻) (and P₁ P₂).
t⊃: t A⁺ P₁ -> t B⁻ P₂ -> t (A⁺ ⊃ B⁻) (imp P₁ P₂).
t∀: ({x:i} t (A⁻ x) (P x)) -> t (∀ A⁻) (all P).
t∃: ({x:i} t (A⁻ x) (P x)) -> t (∃ A⁻) (ex P).

%mode t +A -P.
%worlds (gamma) (t _ _).
%total A (t A _).

th: hjmt -> prop -> type. %name th TransH.
t⁺: th (h⁺ Q Xs) (a Q Xs).
t⁻: th (h⁻ A⁻) P <- t A⁻ P.

%mode th +A -P.
%worlds (gamma) (th _ _).
%total [] (th _ _).

tΩ: pos -> props -> type. %name tΩ TransΩ.
t·: tΩ · ○.
t,: t A⁺ P -> tΩ _Ω _Ψ -> tΩ (A⁺ , _Ω) (P ; _Ψ).

%mode tΩ +A -P.
%worlds (gamma) (tΩ _ _).
%total _Ω (tΩ _Ω _).


%{ === Sequent rules === }%

left: prop -> type. %name left H.
right: prop -> type. %name right D.
right': props -> prop -> type. %name right' D.
%block h: some {P} block {h: left P}.

eeR: ⊧ (prim E Xs) -> right (ee E Xs).

eeL: (⊧ (prim E Xs) -> right Q) -> (left (ee E Xs) -> right Q).

init: Xs ≋ Ys -> left (a Q Xs) -> right (a Q Ys).

ffL: left ff -> right P.

orR₁: right P₁ -> right (or P₁ P₂).

orR₂: right P₂ -> right (or P₁ P₂).

orL: (left P₁ -> right Q)
     -> (left P₂ -> right Q)
     -> (left (or P₁ P₂) -> right Q).

ttR: right tt.

andR: right P₁ -> right P₂ -> right (and P₁ P₂).

andL₁: (left P₁ -> right Q)
       -> (left (and P₁ P₂) -> right Q).

andL₂: (left P₂ -> right Q)
       -> (left (and P₁ P₂) -> right Q).

impR: (left P₁ -> right P₂)
      -> right (imp P₁ P₂).

impL: right P₁
      -> (left P₂ -> right Q)
      -> (left (imp P₁ P₂) -> right Q).

allR: ({t} right (P t)) -> right (all P).

allL: {T:i} (left (P T) -> right Q) -> left (all P) -> right Q.

exR: {T:i} right (P T) -> right (ex P).

exL: ({t} left (P t) -> right Q) -> left (ex P) -> right Q.

nil: right P -> right' ○ P.

cons: (left P -> right' _Ψ Q) -> right' (P ; _Ψ) Q.

%{ === Soundness === }%

%{ Soundness is established in a context where each polarized
hypothesis is mapped to its erasure. }%

soundhyp: hyp A -> th A P -> left P -> type.
%block soundhyps: some {A}{P}{T: th A P}
  block {x: hyp A}{h: left P}{_: soundhyp x T h}.

%block soundctx = (atom⁺ | atom⁻ | soundhyps | univ | casm).

%mode +{A} -{P} +{X} -{T: th A P} -{H} soundhyp X T H.
%worlds (soundctx) (soundhyp _ _ _).
%total [] (soundhyp _ _ _).

%{ The three mutually inductive theorems deal with the three classes of
syntax. }%

soundV: rfoc A⁺ -> t A⁺ P -> right P -> type.
soundN: conc _Ω (A⁻ true) -> tΩ _Ω _Ψ -> t A⁻ P -> right' _Ψ P -> type.
soundSp: lfoc A⁻ (C⁻ true) -> t A⁻ P -> t C⁻ Q -> (left P -> right Q) -> type.

%mode soundV +V +T -D.
%mode soundN +N +TΩ +T -D.
%mode soundSp +Sp +T₁ +T₂ -D.

sound-lem: th (h⁺ Q Xs) P -> left P -> left (a Q Xs) -> type.
-: sound-lem t⁺ H H.
%mode sound-lem +TH +H -H'.
%worlds (soundctx) (sound-lem _ _ _).
%total [] (sound-lem _ _ _).

-: soundV (eR Z) te (eeR Z).

-: soundV (cR D Z) tc (init D H')
  <- soundhyp Z TH H
  <- sound-lem TH H H'.

-: soundV (↓R N) (t↓ T) D
  <- soundN N t· T (nil D).

-: soundV (∨R₁ V) (t∨ T₁ _) (orR₁ D)
  <- soundV V T₁ D.

-: soundV (∨R₂ V) (t∨ _ T₂) (orR₂ D)
  <- soundV V T₂ D.

-: soundV (∃R X V) (t∃ T) (exR X D)
  <- soundV V (T X) D.

-: soundV ⊤⁺R t⊤⁺ ttR.

-: soundV (∧⁺R V₁ V₂) (t∧⁺ T₁ T₂) (andR D₁ D₂)
  <- soundV V₁ T₁ D₁
  <- soundV V₂ T₂ D₂.

-: soundN (foc X _ Sp) t· (TCQ: t C⁻ Q) (nil (D H))
  <- soundhyp X (t⁻ (TAP: t A⁻ P)) (H: left P)
  <- soundSp Sp TAP TCQ (D: left P -> right Q).

-: soundN (↑R V) t· (t↑ T) (nil D)
  <- soundV V T D.

-: soundN ⊤⁻R t· t⊤⁻ (nil ttR).

-: soundN (⊃R N) t· (t⊃ T₁ T₂) (nil (impR D))
  <- soundN N (t, T₁ t·) T₂ (cons [h: left P₁] (nil (D h: right P₂))).

-: soundN (∧⁻R N₁ N₂) t· (t∧⁻ T₁ T₂) (nil (andR D₁ D₂))
  <- soundN N₁ t· T₁ (nil D₁)
  <- soundN N₂ t· T₂ (nil D₂).

-: soundN (∀R N) t· (t∀ T) (nil (allR D))
  <- ({x:i} soundN (N x) t· (T x) (nil (D x))).

-: soundN (cL [x: hyp⁺ Q⁺ Xs] N x) (t, tc TΩ) TCQ (cons D)
  <- ({x: hyp⁺ Q⁺ Xs}{h: left (a Q⁺ Xs)}
       soundhyp x t⁺ h ->
         soundN (N x) TΩ TCQ (D h: right' _Ψ Q)).

-: soundN (↓L [x: hyp⁻ A⁻] N x) (t, (t↓ T) TΩ) TCQ (cons D)
  <- ({x: hyp⁻ A⁻}{h: left P}
       soundhyp x (t⁻ T) h ->
         soundN (N x) TΩ TCQ (D h: right' _Ψ Q)).

sound-eeL: {_Ψ} left (ee E Xs)
           -> (⊧ (prim E Xs) -> right' _Ψ Q)
           -> right' _Ψ Q -> type.
%mode sound-eeL +_Ψ +D1 +D2 -E.
-: sound-eeL ○ (H: left (ee E Xs)) ([x: ⊧ (prim E Xs)] nil (D x)) (nil (eeL ([x] (D x)) H) : right' ○ Q).
-: sound-eeL _ H ([x] cons [h] (D x h)) (cons D')
  <- ({h} sound-eeL _ H ([x] D x h) (D' h)).
%worlds (atom⁺ | atom⁻ | h | univ | casm) (sound-eeL _ _ _ _).
%total _Ψ (sound-eeL _Ψ _ _ _).

-: soundN (eL [x: ⊧ (prim E Xs)] N x) (t, te TΩ) (TCQ : t C⁻ Q) (cons [h: left (ee E Xs)] N'' h)
  <- ({x: ⊧ (prim E Xs)} soundN (N x) TΩ TCQ (N' x : right' _Ψ Q))
  <- ({h: left (ee E Xs)} sound-eeL _ h ([x: ⊧ (prim E Xs)] N' x) (N'' h)).

sound-ffL: {_Ψ} left ff
           -> right' _Ψ Q -> type.
-: sound-ffL _ H (nil (ffL H)).
-: sound-ffL _ H (cons D)
  <- {h} sound-ffL _ H (D h).
%mode +{_Ψ} +{Q} +{H: left ff} -{D: right' _Ψ Q} sound-ffL _Ψ H D.
%worlds (atom⁺ | atom⁻ | h | univ | casm) (sound-ffL _ _ _).
%total _Ψ (sound-ffL _Ψ _ _).

-: soundN ⊥L TΩ TCQ (cons D)
  <- ({h: left ff} sound-ffL _ h (D h)).

sound-orL: {_Ψ} left (or P₁ P₂)
        -> (left P₁ -> right' _Ψ Q)
        -> (left P₂ -> right' _Ψ Q)
        -> right' _Ψ Q -> type.
-: sound-orL _ H ([h₁] nil (D₁ h₁)) ([h₂] nil (D₂ h₂)) (nil (orL D₁ D₂ H)).
-: sound-orL _ H ([h₁] cons (D₁ h₁)) ([h₂] cons (D₂ h₂)) (cons D)
  <- {h} sound-orL _ H ([h₁] D₁ h₁ h) ([h₂] D₂ h₂ h) (D h).
%mode sound-orL +_Ψ +H +D₁ +D₂ -D.
%worlds (atom⁺ | atom⁻ | h | univ | casm) (sound-orL _ _ _ _ _).
%total _Ψ (sound-orL _Ψ _ _ _ _).

-: soundN (∨L N₁ N₂) (t, (t∨ T₁ T₂) TΩ) TCQ (cons D)
  <- soundN N₁ (t, T₁ TΩ) TCQ (cons (D₁: left P₁ -> right' _Ψ Q))
  <- soundN N₂ (t, T₂ TΩ) TCQ (cons (D₂: left P₂ -> right' _Ψ Q))
  <- ({h: left (or P₁ P₂)} sound-orL _ h D₁ D₂ (D h)).

sound-exL: {_Ψ} left (ex P)
        -> ({t} left (P t) -> right' _Ψ Q)
        -> right' _Ψ Q -> type.
-: sound-exL _ H ([t][h₁] nil (D t h₁)) (nil (exL D H)).
-: sound-exL _ H ([t][h₁] cons (D t h₁)) (cons D')
  <- ({h} sound-exL _ H ([t][h₁] D t h₁ h) (D' h)).
%mode sound-exL +_Ψ +H +D -D'.
%worlds (atom⁺ | atom⁻ | h | univ | casm) (sound-exL _ _ _ _).
%total _Ψ (sound-exL _Ψ _ _ _).

-: soundN (∃L N) (t, (t∃ T) TΩ) TCQ (cons D')
  <- ({x} soundN (N x) (t, (T x) TΩ) TCQ (cons (D x)))
  <- ({h: left (ex P)} sound-exL _ h D (D' h)).

-: soundN (⊤⁺L N) (t, t⊤⁺ TΩ) TCQ (cons [h: left tt] D)
  <- soundN N TΩ TCQ (D: right' _Ψ Q).

sound-andL: {_Ψ} left (and P₁ P₂)
         -> (left P₁ -> left P₂ -> right' _Ψ Q)
         -> right' _Ψ Q -> type.
-: sound-andL _ H ([h₁] [h₂] nil (D₁ h₁ h₂))
     (nil (andL₁ ([h₁] andL₂ ([h₂] D₁ h₁ h₂) H) H)).
-: sound-andL _ H ([h₁] [h₂] cons (D₁ h₁ h₂)) (cons D)
  <- {h} sound-andL _ H ([h₁] [h₂] D₁ h₁ h₂ h) (D h).
%mode sound-andL +_Ψ +H +D₁ -D.
%worlds (atom⁺ | atom⁻ | h | univ | casm) (sound-andL _ _ _ _).
%total _Ψ (sound-andL _Ψ _ _ _).

-: soundN (∧⁺L N) (t, (t∧⁺ T₁ T₂) TΩ) TCQ (cons D)
  <- soundN N (t, T₁ (t, T₂ TΩ)) TCQ (cons [h₁] cons [h₂] D₁ h₁ h₂)
  <- ({h: left (and P₁ P₂)} sound-andL _ h D₁ (D h: right' _Ψ Q)).

-: soundSp (p⁻ D) tc tc ([h] init D h).

-: soundSp (↑L N) (t↑ T₁) TCQ D
  <- soundN N (t, T₁ t·) TCQ (cons [h: left P] nil (D h: right Q)).

-: soundSp (⊃L V Sp) (t⊃ T₁ T₂) TCQ (impL D₁ ([h₂: left P₂] D₂ h₂))
  <- soundV V T₁ (D₁: right P₁)
  <- soundSp Sp T₂ TCQ (D₂: left P₂ -> right Q).

-: soundSp (∧⁻L₁ Sp) (t∧⁻ T₁ T₂) TCQ (andL₁ ([h₁: left P₁] D h₁))
  <- soundSp Sp T₁ TCQ (D: left P₁ -> right Q).

-: soundSp (∧⁻L₂ Sp) (t∧⁻ T₁ T₂) TCQ (andL₂ ([h₂: left P₂] D h₂))
  <- soundSp Sp T₂ TCQ (D: left P₂ -> right Q).

-: soundSp (∀L X Sp) (t∀ T: t (∀ A⁻) (all P)) TCQ (allL X ([h: left (P X)] D h))
  <- soundSp Sp (T X) TCQ (D: left (P X) -> right Q).

%worlds (soundctx)
  (soundV _ _ _)
  (soundN _ _ _ _)
  (soundSp _ _ _ _).

%total (V N Sp)
  (soundV V _ _)
  (soundN N _ _ _)
  (soundSp Sp _ _ _).

%{ === Completeness === }%

%{ Completeness is established in a context where each erased
hypothesis is mapped to some polarization. This is the same, type-wise, as
the context for soundness, but the computational interpretation runs the
opposite way 'round. }%

%{ Identity on derivations }%

id: right P -> right P -> type.
refl: id D D.

completehyp: left P -> th A P -> hyp A -> type.
%block completehyps1: some {A}{P}{T: th A P}
  block {x: hyp A}{h: left P}{_: completehyp h T x}.
%block completehyps = (completehyps1 | univ | casm).
%block completectx = (atom⁺ | atom⁻ | completehyps).

%mode completehyp +H -T -X.
%worlds (completectx) (completehyp _ _ _).
%total [] (completehyp _ _ _).

complete: big -> right P -> t A⁻ P -> conc · (A⁻ true) -> type.
%mode complete +S +D +T -N.

-: complete S D (t↑ (t↓ T)) (↑R (↓R M))
  <- complete S D T M.

%{ ==== Initial rules ==== }%

-: complete S (eeR D) (t↑ te) (↑R (eR D)).

ceeL: small
   -> t B⁻ (ee E Xs)
   -> {D: right Q} id D (eeL D₁ (H: left (ee E Xs)))
   -> t C⁻ Q
   -> (hyp⁻ B⁻ -> conc · (C⁻ true))
   -> type.
%mode ceeL +S +TH +D +Id +T -M.

-: ceeL S (t↑ (t↓ TH)) D Id T M
  <- ceeL S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: ceeL S (t↑ (te: t (e E Xs) (ee E Xs))) (eeL D₁ (H: left (ee E Xs))) refl (T: t C⁻ Q) (N': hyp⁻ (↑ (e E Xs)) -> conc · (C⁻ true))
    <- ({x: ⊧ (prim E Xs)} complete (b s) (D₁ x) T (N x))
    <- adm-eL ([x: ⊧ (prim E Xs)] N x) N'.

-: complete (b S)
    (eeL (D₁: ⊧ (prim E Xs) -> right Q) (H: left (ee E Xs)): right Q)
    (T: t C⁻ Q)
    (N X : conc · (C⁻ true))
  <- completehyp H (t⁻ (TH: t A⁻ (ee E Xs))) (X: hyp⁻ A⁻)
  <- ceeL S TH (eeL D₁ H) refl T (N: hyp⁻ A⁻ -> conc · (C⁻ true)).

cinit⁻: t B⁻ (a Q Xs)
     -> {D: right (a Q Ys)} id D (init (D': Xs ≋ Ys) (H: left (a Q Xs)))
     -> (hyp⁻ B⁻ -> conc · (c Q Ys true))
     -> type.
%mode cinit⁻ +TH +D +ID -M.

-: cinit⁻ (t↑ (t↓ TH)) D Id M
  <- cinit⁻ TH D Id (N: hyp⁻ B⁻ -> conc · (c Q Xs true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (c Q Xs true)).

-: cinit⁻ tc (init (D: Xs ≋ Ys) (H: left (a Q Xs))) refl (M D)
    <- adm-init⁻ (M: Xs ≋ Ys -> hyp⁻ (c Q Xs) -> conc · (c Q Ys true)).

%worlds (completectx) (cinit⁻ _ _ _ _).
%total TH (cinit⁻ TH _ _ _).

-: complete S (init D H) tc (M X)
  <- completehyp H (t⁻ TH) X
  <- cinit⁻ TH (init D H) refl (M: hyp⁻ B⁻ -> conc · (c Q Xs true)).

cinit⁺: t B⁻ (a Q Xs)
     -> {D: right (a Q Ys)} id D (init (D': Xs ≋ Ys) (H: left (a Q Xs)))
     -> (hyp⁻ B⁻ -> conc · (↑ (c Q Ys) true))
     -> type.
%mode cinit⁺ +TH +D +ID -M.

-: cinit⁺ (t↑ (t↓ TH)) D Id M
  <- cinit⁺ TH D Id (N: hyp⁻ B⁻ -> conc · (↑ (c Q Xs) true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (↑ (c Q Xs) true)).

-: cinit⁺ (t↑ tc) (init D (H: left (a Q Xs))) refl (M D)
  <- adm-init₁⁺ (M: Xs ≋ Ys -> hyp⁻ (↑ (c Q Xs)) -> conc · (↑ (c Q Ys) true)).

%worlds (completehyps) (cinit⁺ _ _ _ _).
%total TH (cinit⁺ TH _ _ _).

cinith: th B (a (Q: atom ⁺) Xs)
     -> {D: right (a Q Ys)} id D (init (D': Xs ≋ Ys) (H: left (a Q Xs)))
     -> (hyp B -> conc · (↑ (c Q Ys) true))
     -> type.
%mode cinith +TH +D +ID -M.

-: cinith t⁺ (init D (H: left (a Q Xs))) refl (M D)
  <- adm-init₂⁺ (M: Xs ≋ Ys -> hyp⁺ Q Xs -> conc · (↑ (c Q Ys) true)).

-: cinith (t⁻ TH) D Id M
  <- cinit⁺ TH D Id M.

%worlds (completehyps) (cinith _ _ _ _).
%total TH (cinith TH _ _ _).

-: complete S (init D H) (t↑ tc) (M X)
  <- completehyp H TH X
  <- cinith TH (init D H) refl (M: hyp B -> conc · (↑ (c Q Xs) true)).


%{ ==== Disjunction ==== }%

cffL: t B⁻ ff
   -> {D: right Q} id D (ffL (H: left ff))
   -> t C⁻ Q
   -> (hyp⁻ B⁻ -> conc · (C⁻ true))
   -> type.
%mode cffL +TH +D +Id +T -M.

-: cffL (t↑ (t↓ TH)) D Id T M
  <- cffL TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: cffL (t↑ t⊥) (ffL (H: left ff)) refl T M
  <- adm-⊥L (M: hyp⁻ (↑ ⊥) -> conc · (C⁻ true)).

%worlds (completehyps) (cffL _ _ _ _ _).
%total T (cffL T _ _ _ _).

-: complete S (ffL H) T (M X)
  <- completehyp H (t⁻ (TH: t B⁻ ff)) (X: hyp⁻ B⁻)
  <- cffL TH (ffL H) refl T (M: hyp⁻ B⁻ -> conc · (C⁻ true)).

-: complete S (orR₁ D₁) (t↑ (t∨ T₁ T₂)) M
  <- complete S D₁ (t↑ T₁) (N₁: conc · (↑ A⁺ true))
  <- adm-∨R₁ N₁ (M: conc · (↑ (A⁺ ∨ B⁺) true)).

-: complete S (orR₂ D₂) (t↑ (t∨ T₁ T₂)) M
  <- complete S D₂ (t↑ T₂) (N₂: conc · (↑ B⁺ true))
  <- adm-∨R₂ N₂ (M: conc · (↑ (A⁺ ∨ B⁺) true)).

corL: small
   -> t B⁻ (or P₁ P₂)
   -> {D: right Q} id D (orL D₁ D₂ (H: left (or P₁ P₂)))
   -> t C⁻ Q
   -> (hyp⁻ B⁻ -> conc · (C⁻ true))
   -> type.

%mode corL +S +TH +D +Id +T -M.

-: corL S (t↑ (t↓ TH)) D Id T M
  <- corL S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: corL S (t↑ (t∨ T₁ T₂)) (orL D₁ D₂ (H: left (or P₁ P₂))) refl T N
  <- ({x₁: hyp⁻ (↑ B₁⁺)} {h₁: left P₁}
       completehyp h₁ (t⁻ (t↑ T₁)) x₁ ->
         complete (b s) (D₁ h₁) T (N₁ x₁: conc · (C⁻ true)))
  <- ({x₂: hyp⁻ (↑ B₂⁺)} {h₂: left P₂}
       completehyp h₂ (t⁻ (t↑ T₂)) x₂ ->
         complete (b s) (D₂ h₂) T (N₂ x₂: conc · (C⁻ true)))
  <- adm-∨L N₁ N₂ (N: hyp⁻ (↑ (B₁⁺ ∨ B₂⁺)) -> conc · (C⁻ true)).

-: complete (b S) (orL D₁ D₂ H) T (N X)
  <- completehyp H (t⁻ TH) X
  <- corL S TH (orL D₁ D₂ H) refl T (N: hyp⁻ A⁻ -> conc · (C⁻ true)).

%{ ==== Existential Quantification ==== }%

-: complete S (exR X D) (t↑ (t∃ T)) M
  <- complete S D (t↑ (T X)) (N: conc · (↑ (A⁺ X) true))
  <- adm-∃R N (M: conc · (↑ (∃ A⁺) true)).

cexL: small
   -> t B⁻ (ex P)
   -> {D: right Q} id D (exL D₁ (H: left (ex P)))
   -> t C⁻ Q
   -> (hyp⁻ B⁻ -> conc · (C⁻ true))
   -> type.
%mode cexL +S +TH +D +Id +T -M.

-: cexL S (t↑ (t↓ TH)) D Id T M
  <- cexL S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: cexL S (t↑ (t∃ T)) (exL D (H: left (ex P))) refl T' N'
  <- ({z:i}{x₁: hyp⁻ (↑ (B⁺ z))}{h₁: left (P z)}
       completehyp h₁ (t⁻ (t↑ (T z))) x₁ ->
         complete (b s) (D z h₁) T' (N z x₁: conc · (C⁻ true)))
  <- adm-∃L N (N': hyp⁻ (↑ (∃ B⁺)) -> conc · (C⁻ true)).

-: complete (b S) (exL D H) T (N X)
  <- completehyp H (t⁻ TH) X
  <- cexL S TH (exL D H) refl T (N: hyp⁻ A⁻ -> conc · (C⁻ true)).

%{ ==== Conjunction ==== }%

-: complete S ttR (t↑ t⊤⁺) M
  <- adm-⊤⁺R (M: conc · (↑ ⊤⁺ true)).

-: complete S ttR t⊤⁻ M
  <- adm-⊤⁻R (M: conc · (⊤⁻ true)).

-: complete S (andR D₁ D₂) (t↑ (t∧⁺ T₁ T₂)) M
  <- complete S D₁ (t↑ T₁) (N₁: conc · (↑ A⁺ true))
  <- complete S D₂ (t↑ T₂) (N₂: conc · (↑ B⁺ true))
  <- adm-∧⁺R N₁ N₂ (M: conc · (↑ (A⁺ ∧⁺ B⁺) true)).

-: complete S (andR D₁ D₂) (t∧⁻ T₁ T₂) M
  <- complete S D₁ T₁ (N₁: conc · (A⁻ true))
  <- complete S D₂ T₂ (N₂: conc · (B⁻ true))
  <- adm-∧⁻R N₁ N₂ (M: conc · (A⁻ ∧⁻ B⁻ true)).

candL₁: small
    -> t B⁻ (and P₁ P₂)
    -> {D: right Q} id D (andL₁ D₁ (H: left (and P₁ P₂)))
    -> t C⁻ Q
    -> (hyp⁻ B⁻ -> conc · (C⁻ true))
    -> type.
%mode candL₁ +S +TH +D +Id +T -M.

-: candL₁ S (t↑ (t↓ TH)) D Id T M
  <- candL₁ S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: candL₁ S (t↑ (t∧⁺ T₁ T₂)) (andL₁ D₁ (H: left (and P₁ P₂))) refl T M
  <- ({x₁: hyp⁻ (↑ B₁⁺)}{h₁: left P₁}
        completehyp h₁ (t⁻ (t↑ T₁)) x₁ ->
          complete (b s) (D₁ h₁) T (N₁ x₁: conc · (C⁻ true)))
  <- adm-∧⁺L ([x₁: hyp⁻ (↑ B₁⁺)][x₂: hyp⁻ (↑ B₂⁺)] N₁ x₁)
       (M: hyp⁻ (↑ (B₁⁺ ∧⁺ B₂⁺)) -> conc · (C⁻ true)).

-: candL₁ S (t∧⁻ T₁ T₂) (andL₁ D₁ (H: left (and P₁ P₂)))
     refl T M
  <- ({x₁: hyp⁻ B₁⁻}{h₁: left P₁}
        completehyp h₁ (t⁻ T₁) x₁ ->
          complete (b s) (D₁ h₁) T (N₁ x₁: conc · (C⁻ true)))
  <- adm-∧⁻L₁ N₁ (M: hyp⁻ (B₁⁻ ∧⁻ B₂⁻) -> conc · (C⁻ true)).

-: complete (b S) (andL₁ D₁ H) T (M X)
  <- completehyp H (t⁻ TH) X
  <- candL₁ S TH (andL₁ D₁ H) refl T (M: hyp⁻ A⁻ -> conc · (C⁻ true)).

candL₂: small
    -> t B⁻ (and P₁ P₂)
    -> {D: right Q} id D (andL₂ D₁ (H: left (and P₁ P₂)))
    -> t C⁻ Q
    -> (hyp⁻ B⁻ -> conc · (C⁻ true))
    -> type.
%mode candL₂ +S +TH +D +Id +T -M.

-: candL₂ S (t↑ (t↓ TH)) D Id T M
  <- candL₂ S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: candL₂ S (t↑ (t∧⁺ T₁ T₂)) (andL₂ D₂ (H: left (and P₁ P₂))) refl T M
  <- ({x₂: hyp⁻ (↑ B₂⁺)}{h₂: left P₂}
        completehyp h₂ (t⁻ (t↑ T₂)) x₂ ->
          complete (b s) (D₂ h₂) T (N₂ x₂: conc · (C⁻ true)))
  <- adm-∧⁺L ([x₁: hyp⁻ (↑ B₁⁺)][x₂: hyp⁻ (↑ B₂⁺)] N₂ x₂)
       (M: hyp⁻ (↑ (B₁⁺ ∧⁺ B₂⁺)) -> conc · (C⁻ true)).

-: candL₂ S (t∧⁻ T₁ T₂) (andL₂ D₂ (H: left (and P₁ P₂))) refl T M
  <- ({x₂: hyp⁻ B₂⁻}{h₂: left P₂}
        completehyp h₂ (t⁻ T₂) x₂ ->
          complete (b s) (D₂ h₂) T (N₂ x₂: conc · (C⁻ true)))
  <- adm-∧⁻L₂ N₂ (M: hyp⁻ (B₁⁻ ∧⁻ B₂⁻) -> conc · (C⁻ true)).

-: complete (b S) (andL₂ D₂ H) T (M X)
  <- completehyp H (t⁻ TH) X
  <- candL₂ S TH (andL₂ D₂ H) refl T (M: hyp⁻ A⁻ -> conc · (C⁻ true)).


%{ ==== Universal Quantification ==== }%

-: complete S (allR D) (t∀ T) M
  <- ({x} complete S (D x) (T x) (N x: conc · ((A⁻ x) true)))
  <- adm-∀R N (M: conc · ((∀ A⁻) true)).

callL: small
    -> t B⁻ (all P)
    -> {D: right Q} id D (allL X D₁ (H: left (all P)))
    -> t C⁻ Q
    -> (hyp⁻ B⁻ -> conc · (C⁻ true))
    -> type.
%mode callL +S +TH +D +Id +T -M.

-: callL S (t↑ (t↓ TH)) D Id T M
  <- callL S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: callL S (t∀ (T:{x:i} t (A⁻ x) (P x))) (allL (X:i) (D₁: left (P X) -> right Q) (H: left (all P))) refl T₂ M
  <- ({x₂: hyp⁻ (A⁻ X)}{h₂: left (P X)}
        completehyp h₂ (t⁻ (T X)) x₂ ->
          complete (b s) (D₁ h₂) T₂ (N₂ x₂: conc · (C⁻ true)))
  <- adm-∀L N₂ (M: hyp⁻ (∀ A⁻) -> conc · (C⁻ true)).

-: complete (b S) (allL Z (D₁:left (P Z) -> right Q) (D₂:left (all P))) (T:t C⁻ Q) (M X:conc · (C⁻ true))
  <- completehyp D₂ (t⁻ TH) (X)
  <- callL S TH (allL Z D₁ D₂) refl T (M).


%{ ==== Implication ==== }%

-: complete S (impR D₁) (t⊃ T₁ T₂) M
  <- ({x: hyp⁻ (↑ A⁺)}{h: left P₁}
       completehyp h (t⁻ (t↑ T₁)) x ->
         complete S (D₁ h) T₂ (N₁ x: conc · (B⁻ true)))
  <- adm-⊃R N₁ (M: conc · (A⁺ ⊃ B⁻ true)).

cimpL: small
    -> t B⁻ (imp P₁ P₂)
    -> {D: right Q} id D (impL D₁ D₂ (H: left (imp P₁ P₂)))
    -> t C⁻ Q
    -> (hyp⁻ B⁻ -> conc · (C⁻ true))
    -> type.
%mode cimpL +S +TH +D +Id +T -N.

-: cimpL S (t↑ (t↓ TH)) D Id T M
  <- cimpL S TH D Id T (N: hyp⁻ B⁻ -> conc · (C⁻ true))
  <- shifthyp N (M: hyp⁻ (↑ (↓ B⁻)) -> conc · (C⁻ true)).

-: cimpL S (t⊃ T₁ T₂) (impL D₁ D₂ (H: left (imp P₁ P₂))) refl T N
  <- complete (b s) D₁ (t↑ T₁) (N₁: conc · (↑ A⁺ true))
  <- ({x₂: hyp⁻ B⁻}{h₂: left P₂}
       completehyp h₂ (t⁻ T₂) x₂ ->
         complete (b s) (D₂ h₂) T (N₂ x₂: conc · (C⁻ true)))
  <- adm-⊃L N₁ N₂ (N: hyp⁻ (A⁺ ⊃ B⁻) -> conc · (C⁻ true)).

-: complete (b S) (impL D₁ D₂ H) T (N X)
  <- completehyp H (t⁻ TH) X
  <- cimpL S TH (impL D₁ D₂ H) refl T N.

%worlds (completehyps)
  (ceeL _ _ _ _ _ _)
  (corL _ _ _ _ _ _)
  (cexL _ _ _ _ _ _)
  (candL₁ _ _ _ _ _ _)
  (candL₂ _ _ _ _ _ _)
  (callL _ _ _ _ _ _)
  (cimpL _ _ _ _ _ _)
  (complete _ _ _ _).

%total {(D DeeL DorL DexL DandL₁ DandL₂ DallL DimpL)
        (S SeeL SorL SexL SandL₁ SandL₂ SallL SimpL)
        (T TeeL TorL TexL TandL₁ TandL₂ TallL TimpL)}
  (ceeL SeeL TeeL DeeL _ _ _)
  (corL SorL TorL DorL _ _ _)
  (cexL SexL TexL DexL _ _ _)
  (candL₁ SandL₁ TandL₁ DandL₁ _ _ _)
  (candL₂ SandL₂ TandL₂ DandL₂ _ _ _)
  (callL SallL TallL DallL _ _ _)
  (cimpL SimpL TimpL DimpL _ _ _)
  (complete S D T _).


%{ == Inheriting the focused calculus's metatheory == }%

%{ We need the existance of some polarization strategy; we intentionally pick
a middling, undistinghished sort of translation that translates everything as
a negative proposition. It will work great on hereditary Harrop formulas and
not so good if you have lots of disjunction and positive propositions; the only
interesting thing about it is that it's results are reminiscent of Howe's
semi-focused lax logic.. }%

polarize: {P} t (A⁻: typ ⁻) P -> type.
%mode polarize +P -T.

-: polarize (ee E Xs) (t↑ te).
-: polarize (a Q Xs) tc.
-: polarize (a Q Xs) (t↑ tc).
-: polarize ff (t↑ t⊥).
-: polarize (or P₁ P₂) (t↑ (t∨ (t↓ T₁) (t↓ T₂)))
  <- polarize P₁ T₁
  <- polarize P₂ T₂.
-: polarize tt t⊤⁻.
-: polarize (and P₁ P₂) (t∧⁻ T₁ T₂)
  <- polarize P₁ T₁
  <- polarize P₂ T₂.
-: polarize (imp P₁ P₂) (t⊃ (t↓ T₁) T₂)
  <- polarize P₁ T₁
  <- polarize P₂ T₂.
-: polarize (all P) (t∀ T)
  <- ({t} polarize (P t) (T t)).
-: polarize (ex P) (t↑ (t∃ [x] (t↓ (T x))))
  <- ({t} polarize (P t) (T t)).

%worlds (atom⁺ | atom⁻ | univ) (polarize _ _).
%total P (polarize P _).

%block translate: some {A}{P}{TH: th A P}
  block {x: hyp A}{h: left P}{_: soundhyp x TH h}{_: completehyp h TH x}.

unfocused-cut: right P -> (left P -> right Q) -> right Q -> type.
%mode unfocused-cut +D +E -F.

-: unfocused-cut (D: right P) (E: left P -> right Q) F
  <- polarize P (TP: t A⁻ P)
  <- complete (b s) D TP (M: conc · (A⁻ true))
  <- polarize Q (TQ: t C⁻ Q)
  <- ({x: hyp⁻ A⁻}{h: left P}
       completehyp h (t⁻ TP) x ->
         complete (b s) (E h) TQ (N x: conc · (C⁻ true)))
  <- rightN _ (b s) M N N'
  <- soundN N' t· TQ (nil (F: right Q)).

%worlds (translate) (unfocused-cut _ _ _).
%total [] (unfocused-cut _ _ _).

unfocused-identity: {P} (left P -> right P) -> type.
%mode unfocused-identity +P -D.

-: unfocused-identity P D
  <- polarize P (TP: t A⁻ P)
  <- identity (N: hyp⁻ A⁻ -> conc · (A⁻ true))
  <- ({x: hyp⁻ A⁻}{h: left P}
       soundhyp x (t⁻ TP) h ->
         soundN (N x) t· TP (nil (D h: right P))).

%worlds (translate) (unfocused-identity _ _).
%total [] (unfocused-identity _ _).

%{ == Running the theorems == }%

%{ Here are two unfocused derivations of (p ∧ q) ⊃ (r ∧ s) ⊃ (p ∧ t). }%

d₁: {P}{p: atom P}{q: atom P}{r: atom P}{s: atom P}
   right (imp (and (a p ●) (a q ●))
           (imp (and (a r ●) (a s ●))
             (and (a p ●) (a r ●))))
  = [P][p][q][r][s]
      impR [h₁: left (and (a p ●) (a q ●))]
        impR [h₂: left (and (a r ●) (a s ●))]
          andR
            (andL₁ ([h₁': left (a p ●)] init ≋-● h₁') h₁)
            (andL₁ ([h₂': left (a r ●)] init ≋-● h₂') h₂).

d₂: {P}{p: atom P}{q: atom P}{r: atom P}{s: atom P}
   right (imp (and (a p ●) (a q ●))
           (imp (and (a r ●) (a s ●))
             (and (a p ●) (a r ●))))
  = [P][p][q][r][s]
      impR [h₁: left (and (a p ●) (a q ●))]
        impR [h₂: left (and (a r ●) (a s ●))]
          andL₁ ([h₁': left (a p ●)]
            andR
              (andL₂ ([_] (andL₂ ([_] (init ≋-● h₁')) h₁)) h₁)
              (andL₁ ([h₂': left (a r ●)] init ≋-● h₂') h₂))
            h₁.

%{ Here are three different polarizations. }%

%solve t⁻: {p}{q}{r}{s} t (↓(c p ● ∧⁻ c q ●) ⊃ (↓(c r ● ∧⁻ c s ●) ⊃ (c p ● ∧⁻ c r ●))) _.
%solve t⁺: {p}{q}{r}{s} t ((c p ● ∧⁺ c q ●) ⊃ ((c r ● ∧⁺ c s ●) ⊃ ↑(c p ● ∧⁺ c r ●))) _.
%solve t⁼: {p}{q}{r}{s} t (↓(↑(c p ●) ∧⁻ ↑(c q ●))
                            ⊃ ↑(↓(↓(↑(c r ●) ∧⁻ ↑(c s ●))
                                   ⊃ ↑(↓(↑(c p ●) ∧⁻ ↑(c r ●)))))) _.

%{ Under the same "good" polarization, different derivations translate to a
single unique proof. | check=decl }%

%query 1 * {p}{q}{r}{s} complete _ (d₁ ⁻ p q r s) (t⁻ p q r s) (N p q r s).
%query 1 * {p}{q}{r}{s} complete _ (d₂ ⁻ p q r s) (t⁻ p q r s) (N p q r s).

%{ Different polarizations may lead to very differently shaped derivations.
| check=decl }%

%query 1 * {p}{q}{r}{s} complete _ (d₂ ⁺ p q r s) (t⁺ p q r s) (N p q r s).
%query 2 * {p}{q}{r}{s} complete _ (d₂ ⁺ p q r s) (t⁼ p q r s) (N p q r s).

%{ Unfocused derivations of a⁺, a⁺ ⊃ ↑b⁺, ↓↑b⁺ ⊃ c⁻ = c⁻ }%

myprop1 = [a⁺][b⁺][c⁻]
  c a⁺ ● ⊃
  ↓ (c a⁺ ● ⊃ ↑ (c b⁺ ●)) ⊃
  ↓ (↓ (↑ (c b⁺ ●)) ⊃ c c⁻ ●) ⊃
  c c⁻ ●.

focused: {a⁺}{b⁺}{c⁻} conc · (myprop1 a⁺ b⁺ c⁻ true) = [a⁺][b⁺][c⁻]
  ⊃R (cL [xa: hyp⁺ a⁺ ●]
  ⊃R (↓L [xab: hyp⁻ (c a⁺ ● ⊃ ↑ (c b⁺ ●))]
  ⊃R (↓L [xbc: hyp⁻ (↓ (↑ (c b⁺ ●)) ⊃ c c⁻ ●)]
  foc xab sa
    (⊃L (cR ≋-● xa)
    (↑L (cL [xb: hyp⁺ b⁺ ●]
     foc xbc sa
       (⊃L (↓R (↑R (cR ≋-● xb))) (p⁻ ≋-●)))))))).

%define myprop1⁼ = P
%solve tmyprop1: {a⁺}{b⁺}{c⁻} t (myprop1 a⁺ b⁺ c⁻) (P a⁺ b⁺ c⁻).

%define unfocused = D
%solve _: {a⁺}{b⁺}{c⁻}
  soundN (focused a⁺ b⁺ c⁻) t· (tmyprop1 a⁺ b⁺ c⁻) (nil (D a⁺ b⁺ c⁻)).

%define refocused = N
%solve _: {a⁺}{b⁺}{c⁻}
  complete (b s) (unfocused a⁺ b⁺ c⁻) (tmyprop1 a⁺ b⁺ c⁻) (N a⁺ b⁺ c⁻).

id: conc · Suc -> conc · Suc -> type.
refl: id D D.

%query 1 * {a⁺}{b⁺}{c⁻} id (focused a⁺ b⁺ c⁻)   (focused a⁺ b⁺ c⁻).
%query 1 * {a⁺}{b⁺}{c⁻} id (refocused a⁺ b⁺ c⁻) (refocused a⁺ b⁺ c⁻).
%query 0 * {a⁺}{b⁺}{c⁻} id (focused a⁺ b⁺ c⁻)   (refocused a⁺ b⁺ c⁻).

%{ Lax Logic }%

prop': type.                           %name prop' M.

atom': atom P -> prop'.
/\     : prop' -> prop' -> prop'.       %infix right 9 /\.
tt'    : prop'.
\/     : prop' -> prop' -> prop'.       %infix right 8 \/.
ff'    : prop'.
=>     : prop' -> prop' -> prop'.       %infix right 7 =>.
circ'  : prop' -> prop'.

hyp' : prop' -> type.
true' : prop' -> type.

init' : hyp' (atom' P) -> true' (atom' P).
/\R' : true' M -> true' N -> true' (M /\ N).
/\L'  : (hyp' M -> hyp' N -> true' D) -> (hyp' (M /\ N) -> true' D).
ttR' : true' tt'.

\/R1' : true' M -> true' (M \/ N).
\/R2' : true' N -> true' (M \/ N).
\/L' : (hyp' M -> true' D) -> (hyp' N -> true' D) -> (hyp' (M \/ N) -> true' D).
ffL' : hyp' ff' -> true' D.

=>R' : (hyp' M -> true' N) -> true' (M => N).
=>L' : true' M -> (hyp' N -> true' D) -> (hyp' (M => N) -> true' D).

circR' : true' M -> true' (circ' M).
circL' : (hyp' M -> true' (circ' N)) -> hyp' (circ' M) -> true' (circ' N).

%block laxhyp : some {M: prop'} block {v: hyp' M}.

tl: prop' -> i -> prop -> type.  %name tl TLax.
tlc: tl (atom' P) W (P @ W).
tl/\: tl P W A -> tl Q W B -> tl (P /\ Q) W (and A B).
tltt: tl tt' W tt.
tl\/: tl P W A -> tl Q W B -> tl (P \/ Q) W (or A B).
tlff: tl ff' W ff.
tl=>: tl P lax A -> tl Q W B -> tl (P => Q) W (imp A B).
tlcirc: tl P lax A -> tl (circ' P) W A.

%mode tl +A +W -P.
%worlds (laxhyp) (tl _ _ _).
%unique tl +P +W -1A.
%total A (tl A _ _).

lax-weak: tl P W A -> tl P lax A' -> (left A -> right A') -> type.
%mode lax-weak +T1 +T2 -T3.

-: lax-weak
    (tlc: tl (atom' P) lax (P @ lax))
    (tlc: tl (atom' P) lax (P @ lax))
    D
    <- unfocused-identity (P @ lax) D.

-: lax-weak
    (tlc:tl (atom' P) any (P @ any))
    (tlc:tl (atom' P) lax (P @ lax))
    ([d] init (≋-⋆ any-lax ≋-●) d).

-: lax-weak
    (tl=> (T1: tl P lax A) (T2: tl Q any B): tl (P => Q) any (imp A B))
    (tl=> (T1': tl P lax A) (T2': tl Q lax B'): tl (P => Q) lax (imp A B'))
    ([h: left (imp A B)] impR [ha: left A] impL (FA ha) FB h : right B')
    <- lax-weak T1 T1' FA
    <- lax-weak T2 T2' FB.

-: lax-weak
    (tl=> (T1: tl P lax A) (T2: tl Q lax B): tl (P => Q) lax (imp A B))
    (tl=> (T1': tl P lax A) (T2': tl Q lax B): tl (P => Q) lax (imp A B))
    D
    <- unfocused-identity (imp A B) D.

-: lax-weak
    (tl/\ (D1: tl P1 W A1) (D2: tl P2 W B1))
    (tl/\ (E1: tl P1 lax A1') (E2: tl P2 lax B1'))
    ([d: left (and A1 B1)] andR (andL₁ F1 d) (andL₂ F2 d))
   <- lax-weak D1 E1 (F1: left A1 -> right A1')
   <- lax-weak D2 E2 (F2: left B1 -> right B1').

-: lax-weak tltt tltt ([_] ttR).

-: lax-weak
    (tl\/ D1 D2)
    (tl\/ E1 E2)
    ([d: left (or A B)] orL ([d1] orR₁ (F1 d1)) ([d2] orR₂ (F2 d2)) d)
    <- lax-weak D1 E1 F1
    <- lax-weak D2 E2 F2.

-: lax-weak _ _ ffL.

-: lax-weak
    (tlcirc (T1: tl P lax A): tl (circ' P) W A)
    (tlcirc (T2: tl P lax A): tl (circ' P) lax A)
    D
    <- unfocused-identity A D.

%worlds () (lax-weak _ _ _).
%total T1 (lax-weak T1 _ _).

lax-weak':     tl P W A
            -> tl P lax AL
            -> tl (circ' Q) W C
            -> (left A -> right C)
            -> (left AL -> right C)
            -> type.
%mode lax-weak' +T1 +T2 +T3 +D1 -D2.

-: lax-weak'


%.
complete-hyp': hyp' P -> tl P W A -> left A -> type.
%block complete-hyps1': some {P}{W}{A}{T: tl P W A} block {x:left A}{h: hyp' P}{_: complete-hyp' h T x}.
%block complete-hyps' = (complete-hyps1' | univ | casm).
%block completectx' = (atom⁺ | atom⁻ | complete-hyps').

%mode complete-hyp' +H -T -X.
%worlds (completectx') (complete-hyp' _ _ _).
%total [] (complete-hyp' _ _ _).

lax-lem0: tl P W1 AP
           -> tl (circ P) W2 ACP
           -> tl (circ' Q) lax C
           -> (left AP -> right C)
           -> (left ACP -> right C)
           -> type.

%.

complete-lax: true' P -> tl P W A -> right A -> type.
%mode complete-lax +D +T -E.

-: complete-lax
    (init' (D: hyp' (atom' P)))
    (tlc: tl (atom' P) W (P @ W))
    (init F E)
    <- complete-hyp' D _ E
    <- ≋-refl (W ⋆ ●) F.

-: complete-lax
    (=>R' (D: hyp' P -> true' Q))
    (tl=> (E1: tl P W A) (E2: tl Q W B))
    (impR (F: left A -> right B))
    <- ({x:left A}{d: hyp' P} complete-hyp' d E1 x -> complete-lax (D d) E2 (F x)).

-: complete-lax
    (circR' (D: true' P))
    (tlcirc (T: tl P lax A))
    E
    <- complete-lax D T E.

-: complete-lax
    (circL
       (D: hyp' P -> true' (circ' Q))
       (E: hyp' (circ' P))
       : true' (circ' Q))
    (tlcirc
       (T1: tl (circ' Q) lax C)
       : tl (circ' Q) W C)
    (_
       : right C)
    <- complete-hyp' E
       (T2: tl (circ' P) A)
       (D1: left A)
    <- ({d: hyp' P} complete-hyp' d (T3: tl P A') (D2: left A')
          -> complete-lax (D d) T1 (D2: right C))
    <- lax-lem0 T2

%.
ident': prop -> prop -> type.
refl': ident' A A.

tl-uniq: tl P I A -> tl P I B -> ident' A B -> type.
-: tl-uniq _ _ refl'.
%mode tl-uniq +T1 +T2 -Id.
%worlds () (tl-uniq _ _ _).
%total {} (tl-uniq _ _ _).

lax_lem0: tl (circ P) I A -> tl (circ P) lax A' -> (left A -> right A') -> type.
%mode lax_lem0 +T1 +T2 -D.

-: lax_lem0 tlc tlc D'
    <- unfocused-identity _ D'.

-: lax_lem0
    (tlc: tl (atom' P) any (P @ any))
    (tlc: tl (atom' P) lax (P @ lax))
    ([d: left (P @ any)] init (≋-⋆ any-lax ≋-●) d: right (P @ lax)).

-: lax_lem0
    (tl/\ (D1: tl P1 W A1) (D2: tl P2 W B1))
    (tl/\ (E1: tl P1 lax A1') (E2: tl P2 lax B1'))
    ([d: left (and A1 B1)] andR (andL₁ F1 d) (andL₂ F2 d))
   <- lax_lem0 D1 E1 (F1: left A1 -> right A1')
   <- lax_lem0 D2 E2 (F2: left B1 -> right B1').

-: lax_lem0 tltt tltt ([_] ttR).

-: lax_lem0
    (tl\/ D1 D2)
    (tl\/ E1 E2)
    ([d: left (or A B)] orL ([d1] orR₁ (F1 d1)) ([d2] orR₂ (F2 d2)) d)
    <- lax_lem0 D1 E1 F1
    <- lax_lem0 D2 E2 F2.

-: lax_lem0 _ _ ffL.

-: lax_lem0
    (tl=> (D1: tl P any A) (D2: tl Q W B) : tl (P => Q) W (imp A B))
    (tl=> (E1: tl P any A) (E2: tl Q lax B') : tl (P => Q) lax (imp A B'))
    ([d: left (imp A B)] impR [d1: left A] impL (F1 d1) ([d2: left B] (F2 d2)) d: right B')
%    <- tl-uniq D1 E1 _
    <- lax_lem0 D1 E1 (F1: left A -> right A)
    <- lax_lem0 D2 E2 (F2: left B -> right B').

%.
-: ident (A ⊃ B) ([h] imp-r [ha] imp-l h (FA ha) FB)
   <- ident A FA
   <- ident B FB.

%.

-: lax_lem0
    (tlcirc (T1: tl P lax A): tl (circ' P) W A)
    (tlcirc: (T2: tl (atom' P) lax (P @ lax))
    ([d: left ] init (≋-⋆ any-lax ≋-●) d: right (P @ lax)).


%.
lax_lem1: tl P W A -> right A -> tl P lax A' -> right A' -> type.
%mode lax_lem1 +T1 +D1 +T2 -D2.

-: lax_lem1
    (tlc: tl (atom' P) I (P @ I))
    (init C (D1: left (a Q Xs)) (D2: right (a Q Ys)))
    (tlc: tl (atom' P) lax (P @ lax))



%.
%worlds (laxhyp) (tl _ _ _).
%total A (tl A _ _).

sound_lax: right A -> tl P I A -> true' P -> type.
%mode sound_lax +D +T -E.


lax_lem1: right A -> tl P I A -> tl P any A' -> right A' -> type.
%mode lax_lem1 +D1 +T1 +T2 -D2.
